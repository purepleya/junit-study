## 2.2 Definitions
### Lifecycle Method
@BeforeAll, @AfterAll, @BeforeEach, @AfterEach

### Test Class
Test class 는 abstract 여서는 안되며, 단 하나의 생성자(constructor)를 가져야 한다.
1. 최상위 class
2. static member class 
3. @Nested 로 정의되고 테스트 메소드를 하나이상 가지고 있는 class


## 2.3 Test Classes and Methods
test 함수와 lifecycle 함수는 현재 class 내부에 선언되거나, 부모 클래스나 interface 로 부터 상속 받는다.
덧 붙여, 테스트 함수와 라이프 사이클 함수는 추상 함수로 선언 될 수 없으면 return value 를 가질 수 없다. 

---
_Class 와 method의 가시성
test class, test 함수, lifecycle 함수는 public 일 필요는 없으나 private로 선언되서는 안된다.<br/>
일반적으로, 다른 package에서 test class나 test 함수, lifecycle 함수 를 사용하는 경우를 제외하고 public 수정자를 생략하는것을 추천한다._
---
일반적인 test 함수와 lifecycle 함수의 사용 방법은 아래와 같다.
```java
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {
    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @Test
    void abortedTest() {
        assumeTrue("abc".contains("Z"));
        fail("test should have been aborted");
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }
}
```


## 2.4 Display Names
test class 와 test 함수는 @DisplayName 어노테이션을 통해 표시되는 테스트 명(display name)을 변경 할 수 있다. 표시 할 수 있는 테스트 명은 공백, 특수문자, 이모지 까지 가능하고, 변경한 테스트 명은 테스트 보고서나, 테스트 실행기, IDE 에서 표시 된다.

```java
@DisplayName("A special test case")
class DisplayNameDemo {

    @Test
    @DisplayName("Custom test name containing spaces")
    void testWithDisplayNameContainingSpaces() {
    }

    @Test
    @DisplayName("╯°□°）╯")
    void testWithDisplayNameContainingSpecialCharacters() {
    }

    @Test
    @DisplayName("😱")
    void testWithDisplayNameContainingEmoji() {
    }

}
```

### 2.4.1. Display Name Generators
JUnit Jupiter는 @DisplayNameGeneration 어노테이션을 이용하는 custom display name 생성기를 지원한다.  
@DisplayName의 값이 @DisplayNameGeneration를 통해 생성된 값 보다 항상 우선한다.

DisplayNameGenerator를 구현함 으로서 생성기를 만 들 수 있다.  
아래는 Jupiter에서 기본을 제공하는 생성기 들이다.

|DisplayNameGenerator| Behavior                                                 |
|---|----------------------------------------------------------|
|Standard| Junit Jupiter 5.0이 출시 된 이후 사용되어오고 있는 기본 display name 생성기 |
|Simple| 파라미터가 없는 함수의 괄호를 삭제 하는 생성기                               |
|ReplaceUnderscores| 밑줄(underscore)을 공백(space)로 변환하는 생성기                      |
|IndicativeSentences| test와 이를 포함하는 class 명을 합쳐서 완성된 문장을 생성하는 생성기              |

@IndicativeSentencesGeneration 어노테이션을 이용하면, IndicativeSentences 기능에 separator(기본은 ", ")와 기본 display name 생성기를 별도로 정의 할 수 있다.
```java
class DisplayNameGeneratorDemo {

    @Nested
    @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_not_supported {

        @Test
        void if_it_is_zero() {}
//        if it is zero

        @DisplayName("A negative value for year is not supported by the leap year computation.")
        @ParameterizedTest(name = "For example, year {0} is not supported.")
        @ValueSource(ints = { -1, -4 })
        void if_it_is_negative(int year) {}
//        A negative value for year is not supported by the leap year computation.
//            For example, year -1 is not supported.
//            For example, year -4 is not supported.
    }

    @Nested
    @IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
    class A_year_is_a_leap_year {

        @Test
        void if_it_is_divisible_by_4_but_not_by_100() {
        }
//        A year is a leap year -> if it is divisible by 4 but not by 100

        @ParameterizedTest(name = "Year {0} is a leap year.")
        @ValueSource(ints = { 2016, 2020, 2048 })
        void if_it_is_one_of_the_following_years(int year) {
        }
//        A year is a leap year -> if it is one of the following years
//            Year 2016 is a leap year
//            Year 2020 is a leap year
//            Year 2048 is a leap year        
    }

}
```

### 2.4.2. Setting the Default Display Name Generator
junit 속성 파일 (src/test/resources/junit-platform.properties) 에 "junit.jupiter.displayname.generator.default"값을 이용하여 기본 display name 생성기를 설정 할 수 있다.  
@DisplayNameGeneration 어노테이션과 마찬가지로 설정 값 보다 @DisplayName 어노테이션의 값이 더 우선하며, 사용자가 DisplayNameGenerator를 구현하여 생성한 사용자 정의 display name 생성기 클래스도 적용 가능하다.  
```properties
junit.jupiter.displayname.generator.default = org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
```

## 2.5. Assertions
JUnit Jupiter 에서는 Junit 4에서 사용하던 assertion 함수에 Java 8 lambda 사용에 적합한 함수들이 추가 되었다. 
Junit Jupiter의 모든 assertion은 org.junit.jupiter.api.Assertions 클래스에 static 함수로 정의 되어 있다.

```java
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.CountDownLatch;

import example.domain.Person;
import example.util.Calculator;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

class AssertionsDemo {

    private final Calculator calculator = new Calculator();

    private final Person person = new Person("Jane", "Doe");

    @Test
    void standardAssertions() {
        assertEquals(2, calculator.add(1, 1));        
//        마지막 파라미터로 실패 메시지를 전달 할 수 있다.
        assertEquals(4, calculator.multiply(2, 2), "The optional failure message is now the last parameter");
//        supplier를 이용하여 실패 메시지를 지연 할 수 있다.
        assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- " + "to avoid constructing complex messages unnecessarily.");
    }

    @Test
    void groupedAssertions() {
//        assertAll 을 이용해서 복수건을 한번에 검증 할 수 있다.
        assertAll("person",
            () -> assertEquals("Jane", person.getFirstName()),
            () -> assertEquals("Doe", person.getLastName())
        );
    }

    @Test
    void dependentAssertions() {
        assertAll("properties",
            () -> {
//                코드블록 안에 assertion 코드를 작성한 경우, assertion이 실패하면 이후 코드는 실행되지 않는다. 모든 assertion 이 성공한 이후 코드가 실행된다.
                String firstName = person.getFirstName();
                assertNotNull(firstName);
                assertEquals("Jane", firstName);
                
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("e"))
                );
            },
            () -> {
//                assertAll 의 각 개별 assertion은 독립적으로 실행되기 때문에, assertion이 실패하더라도 이후 assertion은 실행된다.
//                아래 코드는 위의 firstName assertion이 실패하더라도 실행된다.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }

    @Test
    void exceptionTesting() {
//        발생이 예상되는 Exception 을 assertThrows 의 첫번째 파라미터로 전달하고, 두번째 파라미터로 예외가 발생하는 코드를 람다로 전달하여
//        예상한 Exception 이 발생하는지 확인한다.
        Exception exception = assertThrows(ArithmeticException.class, () ->
            calculator.divide(1, 0));
        assertEquals("/ by zero", exception.getMessage());
    }

    @Test
    void timeoutNotExceeded() {
//        코드실행 시간이 2초를 넘기면 assertion 실패한다.
        assertTimeout(Duration.ofSeconds(2), () -> {
            Thread.sleep(1000);
        });
    }
    
    @Test
    void timeoutNotExceededWithResult() {
//        코드가 실행되는 동안에 결과값을 리턴하는 경우, 리턴된 결과값을 assertion 할 수 있다.
//        Timeout 이 발생하면 assertion 실패하고 테스트 종료되며, Timeout 이 발생하지 않으면 리턴된 결과값을 assertion 한다.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
            return "a result";
        });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
//        method 참조를 이용하여 assertion 할 수 있다.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("Hello, World!", actualGreeting);
    }
    
    @Test
    void timeoutExceededWithPreemptiveTermination() {
//        timeoutExceededWithPreemptiveTermination 함수를 이용해서 assertTimeout 과 같은 테스트를 진행 할 수 있다.
//        timeoutExceededWithPreemptiveTermination가 assertTimeout 과 다른 점은 아래 설명 참고
        assertTimeoutPreemptively(ofMillis(10), () -> {
            new CountDownLatch(1).await();
        });
    }

    private static String greeting() {
        return "Hello, World!";
    }

}
```

---
_assertTimeoutPreemptively() 함수를 이용한 선제적 타임아웃  
Assertions 클래스에 있는 다양한 assertTimeoutPreemptively()는 Executable 타입이나 Supplier 타입을 호출하는 코드와 분리된 다른 스레드에서 실행한다. Executable이나 Supplier의 코드가 java.lang.ThreadLocal storage를 이용하는 경우 부작용을 일으킬 수 있다.  
Spring Framework 에서 지원하는 트랜잭션 테스트가 대표적인 예 이다.  
특별히 스프링 테스트는  테스트 함수가 실행 되기 전에 TreadLocal을 이용해 트랜잭션 상태를 현재 스레드에 바인딩 한다.  
결과적으로, assertTimeoutPreemptively()함수에 제공된 Excutable이나 Sullpier가 트랜잭션에 포함되는 스프링 관리 콤포넌트를 실행한다면, 콤포넌트가 수행하는 어떤 행동들도 test에서 관리되는 트랜잭션과 함께 롤백되지 않는다.
이와 반대로, test 관리 트랜잭션이 롤백된다 하더라도, 해당 행동들은 db와 같은 persistent sotre에 커밋 된다.  
ThreadLocal storage를 이용하는 다른 프레임웍들도 비슷한 부작용을 일으킬 수 있다._
---

### 2.5.1. Kotlin Assertion Support
JUnit Jupiter 는 Kotlin에 적합한 assertion 함수도 일부 지원하고, 이는 JUnit Jupiter의 org.junit.jupiter.api 패키지의 최 상위 함수로 되어 있다.  
Kotlin 관련 내용은 일단 패스~~~

```kotlin
import example.domain.Person
import example.util.Calculator
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertAll
import org.junit.jupiter.api.assertDoesNotThrow
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.assertTimeout
import org.junit.jupiter.api.assertTimeoutPreemptively
import java.time.Duration

class KotlinAssertionsDemo {

    private val person = Person("Jane", "Doe")
    private val people = setOf(person, Person("John", "Doe"))

    @Test
    fun `exception absence testing`() {
        val calculator = Calculator()
        val result = assertDoesNotThrow("Should not throw an exception") {
            calculator.divide(0, 1)
        }
        assertEquals(0, result)
    }

    @Test
    fun `expected exception testing`() {
        val calculator = Calculator()
        val exception = assertThrows<ArithmeticException> ("Should throw an exception") {
            calculator.divide(1, 0)
        }
        assertEquals("/ by zero", exception.message)
    }

    @Test
    fun `grouped assertions`() {
        assertAll(
            "Person properties",
            { assertEquals("Jane", person.firstName) },
            { assertEquals("Doe", person.lastName) }
        )
    }

    @Test
    fun `grouped assertions from a stream`() {
        assertAll(
            "People with first name starting with J",
            people
                .stream()
                .map {
                    // This mapping returns Stream<() -> Unit>
                    { assertTrue(it.firstName.startsWith("J")) }
                }
        )
    }

    @Test
    fun `grouped assertions from a collection`() {
        assertAll(
            "People with last name of Doe",
            people.map { { assertEquals("Doe", it.lastName) } }
        )
    }

    @Test
    fun `timeout not exceeded testing`() {
        val fibonacciCalculator = FibonacciCalculator()
        val result = assertTimeout(Duration.ofMillis(1000)) {
            fibonacciCalculator.fib(14)
        }
        assertEquals(377, result)
    }

    @Test
    fun `timeout exceeded with preemptive termination`() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(Duration.ofMillis(10)) {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100)
        }
    }
}
```

### 2.5.2. Third-party Assertion Libraries
JUnit Jupiter에 의해 제공되는 assertion 기능들이 많은 테스트 시나리오에 적합하다 하더라도, 때때로 matcher와 같은 추가 기능들이 필요한 경우가 있다.
그런 경우, JUnit 팀은 AssertJ, Hamcrest, Truth 등의 서드파티 assertion 라이브러리를 사용할 것을 권장한다.

예로, matcher와 fluent API의 조합은 assertion을 더 자세하고 읽기 쉽게 만들 수 있다. 그러나 Junit 4에서 지원하고 Hamcrest Matcher에서 채택된 assertThat() 함수는 JUnit Jupiter에서는 지원하지 않는다.
대신, 개발자들은 서드파티 assertion 라이브러리에서 제공하는 matcher를 사용할 것을 권장한다. 

아래 예제는 JUnit Jupiter 테스트에서 Hamcrest의 assertThat() 함수를 사용하는 방법을 보여준다. Hamcrest 라이브러리가 classpath에 추가되어 있는한, assertThat(), is(), equalTo()와 같은 함수들을 static import 할 수 있고, 아래의 assertWithHamcrestMatcher() 함수처럼 테스트에서 사용할 수 있다.

```java
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class HamcrestAssertionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void assertWithHamcrestMatcher() {
        assertThat(calculator.subtract(4, 1), is(equalTo(3)));
    }

}
```
물론, JUnit 4 프로그래밍 모델을 기반으로 한 레거시 테스트는 org.junit.Assert#assertThat을 계속 사용할 수 있다.


## 2.6. Assumptions
JUnit Jupiter 에는 JUnit 4에서 제공하는 assumption 메소드의 하위 집합이 포함되어 있으며, Java 8 람다 표현식과 메소드 참조를 사용하는 데 적합한 몇 가지 메소드가 추가되었다. 
모든 JUnit Jupiter assumption 메소드는 org.junit.jupiter.api.Assumptions 클래스에 static 으로 정의 되어 있다.

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.junit.jupiter.api.Assumptions.assumingThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssumptionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void testOnlyOnCiServer() {
        assumeTrue("CI".equals(System.getenv("ENV")));
    }

    @Test
    void testOnlyOnDeveloperWorkstation() {
//        테스트가 실패하면, 테스트는 실패로 표시되지 않고, 무시된다.
//        테스트가 실패할 경우 "Assumption failed: Aborting test: not on developer workstation" 메시지가 표시된다.
        assumeTrue("DEV".equals(System.getenv("ENV")),
                () -> "Aborting test: not on developer workstation");
    }

    @Test
    void testInAllEnvironments() {
//        첫번째 파라미터가 true 일 경우, 두번째 파라미터로 전달된 람다 표현식이 실행된다.
//        천번째 파라미터가 false 일 경우, 두번째 파라미터로 전달된 람다 표현식은 무시 된다.
        assumingThat("CI".equals(System.getenv("ENV")),
                () -> {
                    assertEquals(2, calculator.divide(4, 2));
                });

        // System.getenv("ENV") 가 CI 이던 아니던, (중간에 assertion 이 실패하지 않는 이상) 무조건 실행 된다.
        assertEquals(42, calculator.multiply(6, 7));
    }

}
```

---
_JUnit Jupiter 5.4 이후로, JUnit 4의 org.junit.Assume 클래스의 메소드를 assumption으로 사용할 수 있다. 특히, JUnit Jupiter는 JUnit 4의 AssumptionViolatedException을 지원하여 테스트가 실패로 표시되는 대신 테스트가 중단되어야 함을 나타낸다._

---


## 2.7. Disabling Tests
테스트 클래스나 개별 테스트 함수를 비 활성화 시키는 방법
1. @Disabled 어노테이션
2. Conditional Test Execution 에서 설명한 어노테이션 사용
3. 사용자 정의 ExecutionCondition을 사용

@Disabled 예제
```java
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

public class DisabledDemo {
    @Disabled("Disabled until bug #42 has been resolved")
    @Test
    void testWillBeSkipped() {
    }

    @Test
    void testWillBeExecuted() {
    }

    @Disabled
    @Nested
    class DisabledTestClass {
        @Test
        void testWillBeSkipped() {
        }
    }

    @Nested
    class EnsabledTestClass {
        @Test
        void testWillBeExecuted() {
        }
    }

}
```
---
_@Disabled를 사용할때 이유를 작성 하지 않아도 된다. 하지만 JUnit 팀은 테스트 클래스나 테스트 함수가 왜 비활성화 되었는지에 대한 간단한 설명을 작성할 것을 권장한다._ 

---


## 2.8. Conditional Test Execution
JUnit Jupiter의 ExecutionCondition 확장 API는 특정 조건에 따라 컨테이너나 테스트 베이스를 프로그램적으로 활성화, 비활성화 할 수 있다.
조건을 지정하는 가장 간단한 예는 @Disabled 어노테이션을 지원하는 DisabledCondition이다. (Disabling Tests 참고)
JUnit Jupiter는 @Disabled외에도 어노테이션 기반의 몇가지 조건(org.junit.jupiter.api.condition)을 지원한다. 이 어노테이션을 사용하면 개발자가 선언적으로 컨테이너나 테스트를 활성화, 비활성화 할 수 있다.
복수개의 ExecutionCondition 이 등록되는 경우, 컨테이너나 테스트는 하나의 조건이라도 비활성화 되면 비활성화 된다.
만약 비활성화 된 이유를 제공하고 싶다면, 각각의 어노테이션에는 disabledReason 속성을 작성하면 된다.

---
_**Composed Annotations**  
이후에 작성된 조건 어노테이션들 역시 사용자 정의 어노테이션을 생성하기 위한 meta-annotation으로 사용할 수 있다.
예를 들어, @TestOnMac 어노테이션은 @Test와 @EnabledOnOs를 조합한 어노테이션이다._

---

---
_달리 명시되지 않는 한, 다음 섹션에 나열된 각 조건 어노테이션은 테스트 인터페이스, 테스트 클래스 또는 테스트 메소드에서 한 번만 선언할 수 있다. 조건 어노테이션이 직접적으로, 간접적으로 또는 메타로 한 요소에 여러 번 존재하는 경우, JUnit에 의해 발견된 첫 번째 어노테이션만 사용된다. 추가 선언은 무시된다.  
그러나, 각 조건 어노테이션은 org.junit.jupiter.api.condition 패키지의 다른 조건 어노테이션과 함께 사용될 수 있다._

---

### 2.8.1. Operating System and Architecture Conditions
컨테이너 나 테스트는 @EnabledOnOs와 @DisabledOnOs 어노테이션을 이용해서 특정 운영체제나 아키텍처에서만 실행되도록 지정할 수 있다.

_Conditional execution based on operating system_
```java
@Test
@EnabledOnOs(MAC)
void onlyOnMacOs() {
    // ...
}

@TestOnMac
void testOnMac() {
    // ...
}

@Test
@EnabledOnOs({ LINUX, MAC })
void onLinuxOrMac() {
    // ...
}

@Test
@DisabledOnOs(WINDOWS)
void notOnWindows() {
    // ...
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Test
@EnabledOnOs(MAC)
@interface TestOnMac {
}
```
_Conditional execution based on architecture_
```java
@Test
@EnabledOnOs(architectures = "aarch64")
void onAarch64() {
    // ...
}

@Test
@DisabledOnOs(architectures = "x86_64")
void notOnX86_64() {
    // ...
}

@Test
@EnabledOnOs(value = MAC, architectures = "aarch64")
void onNewMacs() {
    // ...
}

@Test
@DisabledOnOs(value = MAC, architectures = "aarch64")
void notOnNewMacs() {
    // ...
}
```

### 2.8.2. Java Runtime Environment Conditions
컨테이너나 테스트는 @EnabledOnJre와 @DisabledOnJre 어노테이션을 이용해서 특정 버전의 자바 런타임 환경에서만 실행되도록 지정하거나, @EnabledForJreRange와 @DisabledForJreRange 어노테이션을 이용해서 실행되거나 실행되지 않을 JRE의 범위를 지정 할 수 있다. 범위는 JRE.JAVA_8을 하한 (min)으로 JRE.OTHER를 상한 (max)으로 기본값으로 사용하며, 반 개방 범위의 사용을 허용한다.

```java
@Test
@EnabledOnJre(JAVA_8)
void onlyOnJava8() {
    // ...
}

@Test
@EnabledOnJre({ JAVA_9, JAVA_10 })
void onJava9Or10() {
    // ...
}

@Test
@EnabledForJreRange(min = JAVA_9, max = JAVA_11)
void fromJava9to11() {
    // ...
}

@Test
@EnabledForJreRange(min = JAVA_9)
void fromJava9toCurrentJavaFeatureNumber() {
    // ...
}

@Test
@EnabledForJreRange(max = JAVA_11)
void fromJava8To11() {
    // ...
}

@Test
@DisabledOnJre(JAVA_9)
void notOnJava9() {
    // ...
}

@Test
@DisabledForJreRange(min = JAVA_9, max = JAVA_11)
void notFromJava9to11() {
    // ...
}

@Test
@DisabledForJreRange(min = JAVA_9)
void notFromJava9toCurrentJavaFeatureNumber() {
    // ...
}

@Test
@DisabledForJreRange(max = JAVA_11)
void notFromJava8to11() {
    // ...
}
```

### 2.8.3. Native Image Conditions
@EnabledInNativeImage, @DisabledInNativeImage 어노테이션을 이용하여 컨테이너나 테스트가 GraalVM 네이티브 이미지에서만 실행되도록 지정할 수 있다.
이러한 어노테이션은 일반적으로 GraalVM Native Build Tools 프로젝트의 Gradle과 Maven 플러그인을 사용하여 네이티브 이미지 내에서 테스트를 실행할 때 사용된다.

```java
@Test
@EnabledInNativeImage
void onlyWithinNativeImage() {
    // ...
}

@Test
@DisabledInNativeImage
void neverWithinNativeImage() {
    // ...
}
```

### 2.8.4. System Property Conditions
@EnabledIfSystemProperty 와 @DisabledIfSystemProperty annotations을 이용하여 JVM 환경 변수의 값에 따라 테스트를 활성화 또는 비활성화 할 수 있다.
matches 속성으로 지정된 값은 정규 표현식으로 해석된다.

```java
@Test
@EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*")
void onlyOn64BitArchitectures() {
    // ...
}

@Test
@DisabledIfSystemProperty(named = "ci-server", matches = "true")
void notOnCiServer() {
    // ...
}
```
---
_JUnit Jupiter 5.6 이후, @EnabledIfSystemProperty 와 @DisabledIfSystemProperty는 반복 사용이 가능하다.
따라서 이러한 어노테이션은 테스트 인터페이스, 테스트 클래스 또는 테스트 메소드에 여러 번 선언될 수 있다.
특히, 이러한 어노테이션은 직접적, 간접적 또는 메타로 선언될 수 있다._

---

### 2.8.5. Environment Variable Conditions
@EnabledIfEnvironmentVariable, @DisabledIfEnvironmentVariable 어노테이션을 이용해서 OS 환경 변수의 값에 따라 테스트를 활성화 또는 비활성화 할 수 있다.
matches 속성으로 지정된 값은 정규 표현식으로 해석된다.

```java
@Test
@EnabledIfEnvironmentVariable(named = "ENV", matches = "staging-server")
void onlyOnStagingServer() {
    // ...
}

@Test
@DisabledIfEnvironmentVariable(named = "ENV", matches = ".*development.*")
void notOnDeveloperWorkstation() {
    // ...
}
```
---
_JUnit Jupiter 5.6 이후, @EnabledIfEnvironmentVariable 와 @DisabledIfEnvironmentVariable는 반복 사용이 가능하다.
따라서 이러한 어노테이션은 테스트 인터페이스, 테스트 클래스 또는 테스트 메소드에 여러 번 선언될 수 있다.
특히, 이러한 어노테이션은 직접적, 간접적 또는 메타로 선언될 수 있다._

---

### 2.8.6. Custom Conditions
ExecutionCondition을 구현하는 대신 @EnabledIf 와 @DisabledIf 어노테이션을 통해 조건 메소드를 기반으로 컨테이너나 테스트를 활성화 또는 비활성화 할 수 있다.
조건 메소드는 boolean 반환 타입을 가져야 하며 인자를 받지 않거나 단일 ExtensionContext 인자를 받아야 한다.

아래 테스트는 @EnabledIf 와 @DisabledIf 어노테이션에 customCondition 메소드를 설정하여 테스트를 활성화 또는 비활성화 하는 예제를 보여준다.


```java
@Test
@EnabledIf("customCondition")
void enabled() {
    // ...
}

@Test
@DisabledIf("customCondition")
void disabled() {
    // ...
}

boolean customCondition() {
    return true;
}
```
조건 메소드는 테스트 클래스 외부에 위치 할 수 있다. 이 경우 다음 예제와 같이 완전히 정규화된 이름으로 참조되어야 한다.
```java
package example;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIf;

class ExternalCustomConditionDemo {

    @Test
    @EnabledIf("example.ExternalCondition#customCondition")
    void enabled() {
        // ...
    }

}

class ExternalCondition {

    static boolean customCondition() {
        return true;
    }

}
```
---
_조건 메소드가 static 이어야 하는 몇가지 경우들이 있다:_
_@EnabledIf 또는 @DisabledIf 어노테이션이 class 수준에서 사용되는 경우_
_@EnabledIf 또는 @DisabledIf 어노테이션이 @ParameterizedTest 또는 @TestTemplate 메소드에서 사용되는 경우_
_조건 메소드가 외부 클래스에 위치하는 경우_
_그외에도, 조건 메소드는 static 메소드 또는 instance 메소드일 수 있다._ 

_예로, java.awt.GraphicsEnvironment는 현재 환경이 그래픽 디스플레이를 지원하지 않는지를 확인하는 데 사용할 수 있는 public static boolean isHeadless() 메소드를 제공한다.
따라서 아래 예제와 같이 그래픽 지원에 의존하는 테스트가 그러한 지원이 사용 불가능한 경우 비활성화 할 수 있다._
```java
@DisabledIf(value = "java.awt.GraphicsEnvironment#isHeadless", disabledReason = "headless environment")
```

---


## 2.9. Tagging and Filtering
@Tag 어노테이션을 이용해서 클래스나 메소드에 tag를 달 수 있다.
tag는 이후 테스트 검색 및 실행에 사용될 수 있다. tag에 대한 자세한 내용은 JUnit Platform의 Tag 부분 참고.

```java
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

@Tag("fast")
@Tag("model")
class TaggingDemo {

    @Test
    @Tag("taxes")
    void testingTaxCalculation() {
    }

}
```


## 2.10. Test Execution Order
기본적으로, 테스트 클래스와 메소드는 결정적이지만 의도적으로 명확하지 않은 알고리즘을 사용하여 정렬된다.
이렇게 하면 테스트 도구 모음의 후속 실행에서 동일한 순서로 테스트 클래스와 테스트 메서드를 실행하므로 반복 해서 빌드가 가능합니다.

### 2.10.1. Method Order
단위 테스트가 실행 순서에 영향을 받지는 않지만, 특정 테스트 메소드의 실행 순서를 제어하고 싶은 경우가 있다.
예로, 통합테스트나 기능테스트를 작성할때(특별히 @TestInstance(Lifecycle.PER_CLASS)를 적용하는 경우)는 테스트 순서가 중요한 경우가 있다.

테스트 함수의 실행 순서를 제어하기 위해서는 @TestMethodOrder 어노테이션에 MethodOrderer 구현체를 지정하면 된다.
사용자 지정 MethodOrderer를 구현하거나 다음 내장 MethodOrderer 구현 중 하나를 사용할 수 있다.
* MethodOrderer.DisplayName: 테스트 메소드를 display 이름의 알파벳 순서로 정렬한다.
* MethodOrderer.MethodName: 테스트 메소드 이름과 형식 매개 변수 목록에 따라 테스트 메소드를 알파벳 순서로 정렬한다.
* MethodOrderer.OrderAnnotation: @Order 어노테이션에 지정된 값에 따라 테스트 메소드를 정렬한다. 
* MethodOrderer.Random: 테스트 메소드를 난수로 정렬하고 사용자 정의 시드를 구성할 수 있다. 
* MethodOrderer.Alphanumeric: 테스트 메소드 이름과 형식 매개 변수 목록에 따라 테스트 메소드를 알파벳 순서로 정렬한다. MethodOrderer.MethodName가 생기면서 deprecated 되었다. 6.0 부터는 삭제될 것이다.

```java
public class MethodOrderDemo {

    @Nested
    @TestMethodOrder(MethodOrderer.DisplayName.class)
    class DisplayNameDemo {
//        실행 순서
//        testA
//        testB
//        testD()
//        testE
        
        @Test
        @DisplayName("testA")
        void testA() {}

        @Test
        @DisplayName("testB")
        void testB() {}

        @Test
        @DisplayName("testE")
        void testC() {}

        @Test
        void testD() {}
    }

    @Nested
    @TestMethodOrder(MethodOrderer.MethodName.class)
    class MethodNameDemo {
//        실행 순서
//        testA
//        testB
//        testE
//        testD()

        @Test
        @DisplayName("testA")
        void testA() {}

        @Test
        @DisplayName("testB")
        void testB() {}

        @Test
        @DisplayName("testE")
        void testC() {}

        @Test
        void testD() {}
    }


    @Nested
    @TestMethodOrder(MethodOrderer.OrderAnnotation.class)
    class OrderAnnotationDemo {
//        실행순서
//        testB()
//        testD()
//        testC()
//        testA()
            
        @Test
        void testA() {}

        @Test
        @Order(0)
        void testB() {}

        @Test
        @Order(5)
        void testC() {}

        @Test
        @Order(1)
        void testD() {}
    }


    @Nested
    @TestMethodOrder(MethodOrderer.Random.class)
    class RandomDemo {
//        실행순서 가 매번 다름
        @Test
        void testA() {}

        @Test
        void testB() {}

        @Test
        void testC() {}

        @Test
        void testD() {}
    }

}
```

#### Setting the Default Method Orderer
junit.jupiter.testmethod.order.default 설정 값을 통해서 기본 MethodOrderer를 지정(전체 경로를 모두 작성해야 한다)할 수 있다.
@TestMethodOrder 어노테이션으로 설정할때와 마찬가지로 MethodOrderer 구현체를 지정해야한다.
@TestMethodOrder 가 별도로 지정되지 않은 경우에 설정된다.

MethodOrderer.OrderAnnotation 메소드 순서를 기본으로 사용하려면 다음과 같이 설정하면 된다.
(직접 구현한 MethodOrderer의 구현체를 사용하려면 아래와 같이 전체 경로를 작성해 주면 된다.)
```properties
junit.jupiter.testmethod.order.default = org.junit.jupiter.api.MethodOrderer$OrderAnnotation
```

### 2.10.2. Class Order
테스트 클래스들이 일반적으로 그 실행순서에 영향을 받지 않는다 하더라도, 특정 테스트 클래스의 실행 순서를 제어하고 싶은 경우가 있다.

테스트클래스 사이에 의도되지 않은 의존성이 없는지 확인하기 위해 테스트 클래스를 무작위로 실행하고 싶은 경우도 있고,
아래 시나리오 처럼 빌드타임 최적화를 위해 테스트 클래스의 순서를 정하고 싶은 경우도 있다.
* 이전에 실패한 테스트와 빠른 테스트를 먼저 실행: "fail fast" 모드
* 병렬 실행이 활성화된 경우, 더 긴 테스트를 먼저 예약: "shortest test plan execution duration" 모드
* 그외 기타 등등

전체 테스트 클래스의 실행순서를 설정하기 위해서는 junit.jupiter.testclass.order.default 설정 값을 통해서 기본 ClassOrderer를 지정(지정되는 클래스는 ClassOrderer를 구현해야하고, 전체 경로를 모두 작성해야 한다)할 수 있다.
아래 나열된 기본으로 제공하는 ClassOrderer 구현체를 사용해도 되고, ClassOrderer를 직접 구현하여 사용해도 된다.

* ClassOrderer.ClassName: 전체 경로의 클래스 이름 기준으로 알파벳 순서 정렬 한다. 
* ClassOrderer.DisplayName: 클래스의 Display Name 기준으로 알파벳 순서 정렬 한다.
* ClassOrderer.OrderAnnotation: @Order 어노테이션의 숫자 값(value) 기준으로 정렬 한다.
* ClassOrderer.Random: 테스트 클래스를 난수로 정렬하고 사용자 정의 시드를 구성할 수 있다.

```java

@TestClassOrder(ClassOrderer.ClassName.class)
public class MethodOrderDemo {

    @Nested
    class Aaa {
        @Test
        void testA() {}
    }

    @Nested
    class Ccc {
        @Test
        void testC() {}
    }


    @Nested
    class Bbb {
        @Test
        void testB() {}
    }
}
```

기본 ClassOrderer를 지정하고 싶다면 properties 파일((e.g., in src/test/resources/junit-platform.properties))에 아래와 같이 설정하면 된다.
```properties
junit.jupiter.testclass.order.default = org.junit.jupiter.api.ClassOrderer$OrderAnnotation

```
설정된 ClassOrderer는 모든 최상위 테스트 클래스(정적 중첩 테스트 클래스 포함)와 @Nested 테스트 클래스에 적용된다.  
_최상위 테스트 클래스는 서로에게 상대적인 순서를 부여받는다. 반면, @Nested 테스트 클래스는 동일한 클래스에 포함된 다른 @Nested 테스트 클래스에 상대적인 순서를 부여받는다._

@Nested 테스트 클래스의 순서를 지역적으로(locally) 지정하기 위해서는, @TestClassOrder 어노테이션을 상위(@Nested 테스트클래스를 포함하느) 클래스에 사용하면 된다.
이때 @TestClassOrder 어노테이션에 ClassOrderer 구현체를 지정해 준다.
지정된 ClassOrderer는 @Nested 테스트 클래스와 그 하위 @Nested 테스트 클래스에 순차적으로(recursively) 적용된다.

지역적으로(locally) 지정된 @TestClassOrder 어노테이션은 상속받은 @TestClassOrder 어노테이션 또는 junit.jupiter.testclass.order.default 설정 값으로 지정된 ClassOrderer를 항상 오버라이드한다.


## 2.11. Test Instance Lifecycle
개별 테스트 메소드를 독립적으로 실행하고 변경가능한 테스트 인스턴스 상태로 인해 예상치 못한 부작용이 발생하는 것을 막기 위해,
JUnit은 각 테스트 메소드를 실행하기 전에 테스트 클래스의 새로운 인스턴스를 생성한다.
이 "per-method" 테스트 인스턴스 라이프사이클은 JUnit Jupiter의 기본 동작이며, 이전 버전의 JUnit과 유사하다.

_테스트 클래스는 테스트메소드가 조건에 따라 disabled(@Disabled, @DisabledOnOs, 등) 되더라도 "per-method" 테스트 인스턴스 라이프사이클모드가 가동중 이라면 여전히 존재 한다._

만약 JUnit Jupiter 가 모든 테스트 메소드를 동일한 테스트 인스턴스에서 실행하도록 하고 싶다면, 테스트 클래스에 @TestInstance(Lifecycle.PER_CLASS) 어노테이션을 사용하면 된다.
이 모드를 사용하는 경우, 새로운 테스트 클래스의 인스턴스는 테스트 클래스당 한번만 생성된다.
따라서, 테스트 메소드가 인스턴스 변수에 저장된 상태 의존하고 있다면, @BeforeEach 또는 @AfterEach 메소드에서 해당 상태를 재설정해야 한다.

"per-class" 모드는 "per-method" 모드보다 몇가지 추가적인 이점이 있다. 
특별히, "per-class" 모드에서 @BeforeAll, @AfterAll 어노테이션은 인터페이스의 default 메소드 뿐 아니라 non-static 메소드에도 선언할 수 있다.
@BeforeAll, @AfterAll 어노테이션은 @Nested 테스트 클래스에서도 사용할 수 있다.

_Java 16 버전 이후로, @BeforeAll, @AfterAll 어노테이션은 @Nested 테스트 클래스에서 static으로 선언할 수 있다._

코틀린으로 테스트 모드를 작성하고 있다면, 
"per-class" 테스트 인스턴스 라이프 사이클 모드로 변환하여 non-static @BeforeAll, @AfterAll 라이프사이클 메소드 및 @MethodSource 팩토리 메소드를 구현하는 것이 더 쉽다. 

### 2.11.1. Changing the Default Test Instance Lifecycle
테스트 클래스나 테스트 인터페이스에 @TestInstance 어노테이션을 사용하지 않은경우, JUnit Jupiter는 기본 라이프사이클 모드를 사용한다.
기본 모드는 PER_METHOD 이다. 하지만, 전체 테스트 계획의 기본 실행을 변경할 수 있다.
테스트 인스턴스의 기본 라이프사이클 모드를 변경하기 위해서는 junit.jupiter.testinstance.lifecycle.default 설정값을 TestInstance.Lifecycle 에 정의 되어 있는 enum 으로 지정하면 된다. 
해당 설정 값은 JVM 시스템 프로퍼티나, LauncherDiscoveryRequest 에 전달되는 설정 파라미터, 또는 JUnit Platform 설정 파일에 지정할 수 있다.

아래 예 처럼 JVM 시스템 속성값을 이용해서 테스트 인스턴스의 라이프 사이클 모드를 Lifecycle.PER_CLASS 로 설정 할 수 있다.
```shell
-Djunit.jupiter.testinstance.lifecycle.default=per_class
```

JUnit 플랫폼 설정 파일을 통한 테스트 인스턴스의 라이프사이클 모드 설정은 조금더 강력한 방법이다. 왜냐하면 설정 파일은 버전 관리 시스템으로 관리 가능해서 IDE나 빌드 시스템에서 사용할 수 있기 때문이다.

JUnit Platform 설정 파일로 테스트 인스턴스의 기본 라이프 사이클 모드를 Lifecycle.PER_CLASS로 설정하기 위해서는 "junit-platform.properties"파일을 클래스 패스의 최 상단 (e.g., src/test/resources)에 생성하고 아래 내용을 추가한다.  
```shell
junit.jupiter.testinstance.lifecycle.default = per_class
```

_테스트 인스턴스의 기본 라이프 사이클 모드 변경이 일관되게 적용되지 않는 경우, 예측 할 수 없는 결과와 빌드가 깨지는 문제를 발생시킬 수 있다.
예로, 빌드 설정은 "per-class" 라이프 사이클 모드를 기본으로 구성하지만 IDE에서 테스트를 실행할 때는 "per-method" 라이프 사이클 모드를 사용한다면,
빌드 서버에서 발생하는 오류를 디버깅하는 것이 어려울 수 있다.
따라서, JVM 시스템 변수 보다는 JUnit 플랫폼 설정 파일로 기본 설정을 변경하는 것이 좋다._



## 2.12. Nested Tests
@Nested 테스트는 테스트 작성자들이 여러 테스트 그룹 간의 관계를 표현하는 더 많은 기능을 제공한다.
nested 테스트는 자바의 중첩 클래스를 사용하고 테스트 구조에 대한 계층적인 생각을 용이하게 한다.

_Nested test suite for testing a stack_
```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.EmptyStackException;
import java.util.Stack;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

@DisplayName("A stack")
class TestingAStackDemo {

    Stack<Object> stack;

    @Test
    @DisplayName("is instantiated with new Stack()")
    void isInstantiatedWithNew() {
        new Stack<>();
    }

    @Nested
    @DisplayName("when new")
    class WhenNew {

        @BeforeEach
        void createNewStack() {
            stack = new Stack<>();
        }

        @Test
        @DisplayName("is empty")
        void isEmpty() {
            assertTrue(stack.isEmpty());
        }

        @Test
        @DisplayName("throws EmptyStackException when popped")
        void throwsExceptionWhenPopped() {
            assertThrows(EmptyStackException.class, stack::pop);
        }

        @Test
        @DisplayName("throws EmptyStackException when peeked")
        void throwsExceptionWhenPeeked() {
            assertThrows(EmptyStackException.class, stack::peek);
        }

        @Nested
        @DisplayName("after pushing an element")
        class AfterPushing {

            String anElement = "an element";

            @BeforeEach
            void pushAnElement() {
                stack.push(anElement);
            }

            @Test
            @DisplayName("it is no longer empty")
            void isNotEmpty() {
                assertFalse(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when popped and is empty")
            void returnElementWhenPopped() {
                assertEquals(anElement, stack.pop());
                assertTrue(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when peeked but remains not empty")
            void returnElementWhenPeeked() {
                assertEquals(anElement, stack.peek());
                assertFalse(stack.isEmpty());
            }
        }
    }
}
```
예제를 실행하면 IDE에서는 테스트 실행 트리가 표시된다.  
이 예제에서, 외부 테스트의 전제 조건은 셋업을 위한 용도로 계층적 라이프사이클 메소드를 통해 내부 테스트에서 사용되는데, 
createNewStack() 함수는 @BeforeEach 라이프사이클 메소드로 정의되었고, 그것이 정의된 클래스와 그 하위의 모든 레벨에서 사용된다.

외부 테스트 클래스의 셋업 코드는 내부 테스트가 실행되기 전에 실행되기 때문에, 모든 테스트를 독립적으로 실행할 수 있다. 
외부테스트를 실행하지 않고 내부 테스트만 실행했다 하더라도 외부의 셋업 코드는 항상 실행된다.

_non-static nested 클래스만 @Nested 테스트로 사용될 수 있다. static nested 클래스는 @Nested 테스트로 사용될 수 없다.
중첩은 임의로 깊게 할 수 있으며, 이러한 내부 클래스는 하나의 예외를 제외하고 전체 라이프사이클 지원을 받는다. (@BeforeAll 과 @AfterAll 메소드는 기본적으로 작동하지 않는다.)
이유는 Java 16 이전에는 내부 클래스에서 static 멤버를 허용하지 않기 때문이다.
그러나, 이 제한은 @Nested 테스트 클래스에 @TestInstance(Lifecycle.PER_CLASS) 어노테이션을 사용하여 우회할 수 있다.
만약 Java 16이상의 버전을 사용한다면, @BeforeAll 과 @AfterAll 메소드는 @Nested 테스트 클래스에서 static으로 선언할 수 있고, 이 제한은 더이상 적용되지 않는다._


## 2.13. Dependency Injection for Constructors and Methods
JUnit 이전 버전에서 테스트 생성자나 메소드는 파라미터를 가질 수 없었다. (최소한 표준 Runner 구현체에서는)
JUnit Jupiter의 주 변경 점 중 하나는 테스트 생성자와 메소드가 이제 파라미터를 가질 수 있다는 것이다.
이는 더 큰 유연성을 제공하고 생성자와 메소드에 의존성 주입을 가능하게 한다.

ParameterResolver 인터페이스는 런타임에 동적으로 파라미터를 처리하는 테스트 확장을 위한 API를 정의한다.
테스트 클래스 생성자, 테스트 메소드 또는 라이프사이클 메소드가 파라미터를 받는 다면, 파라미터는 등록된 ParameterResolver에 의해 런타임에 처리된다. 

3개의 기본 resolver가 있다.

* TestInfoParameterResolver: 생성자 나 메소드 파라미터가 TestInfo 타입이면, TestInfoParameterResolver는 현재 컨테이너 또는 테스트에 해당하는 TestInfo 인스턴스를 파라미터의 값으로 제공한다. 
TestInfo 는 현재 컨테이너나 테스트의 디스플레이 이름, 테스트 클래스, 테스트 메소드 및 관련 태그와 같은 현재 컨테이너 또는 테스트에 대한 정보를 검색하는 데 사용할 수 있다.
디스플레이 이름은 테스트 클래스나 메소드 또는 @DisplayName 어노테이션을 통해 설정된 사용자 정의 이름을 말한다.
TestInfo는 JUnit 4의 TestName 규칙을 대체하는 역할을 한다. 다음은 TestInfo가 테스트 생성자, @BeforeEach 메소드 및 @Test 메소드에 주입되는 방법을 보여준다.

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

@DisplayName("TestInfo Demo")
class TestInfoDemo {

    TestInfoDemo(TestInfo testInfo) {
        assertEquals("TestInfo Demo", testInfo.getDisplayName());
    }

    @BeforeEach
    void init(TestInfo testInfo) {
        String displayName = testInfo.getDisplayName();
        assertTrue(displayName.equals("TEST 1") || displayName.equals("test2()"));
    }

    @Test
    @DisplayName("TEST 1")
    @Tag("my-tag")
    void test1(TestInfo testInfo) {
        assertEquals("TEST 1", testInfo.getDisplayName());
        assertTrue(testInfo.getTags().contains("my-tag"));
    }

    @Test
    void test2() {
    }

}
```

* RepetitionExtension: 만약 @RepeatedTest, @BeforeEach, @AfterEach 메소드의 파라미터가 RepetitionInfo 타입이면, RepetitionExtension는 RepetitionInfo 인스턴스를 제공한다.
RepetitionInfo는 현재 반복에 대한 정보, 총 반복 횟수, 실패한 반복 횟수 및 해당 @RepeatedTest의 실패 임계값을 검색하는 데 사용할 수 있다.
그러나 RepetitionExtension은 @RepeatedTest의 컨텍스트 외부에서 등록되지 않는다. Repeated Test Examples를 참고하자.
* TestReporterParameterResolver: 생성자나 메소드 파라미터가 TestReporter 타입이면, TestReporterParameterResolver는 TestReporter 인스턴스를 제공한다.
TestReporter는 현재 테스트 실행에 대한 추가 데이터를 게시(publish) 하는데 사용된다. 데이터는 TestExecutionListener의 reportingEntryPublished()함수에 사용되고, IDE나 리포트에 포함될 수 있다.
JUnit Jupiter에서 stdout이나 JUnit4의 stderr을 이용해서 정보를 출력하고자 할때는 TestReporter를 사용해야한다.
@RunWith(JUnitPlatform.class)를 사용하면 모든 보고된 항목이 stdout에 출력된다.

몇몇 IDE는 보고된 항목을 stdout에 출력하거나 테스트 결과의 사용자 인터페이스에 표시한다.

```java
class TestReporterDemo {

    @Test
    void reportSingleValue(TestReporter testReporter) {
        testReporter.publishEntry("a status message");
    }

    @Test
    void reportKeyValuePair(TestReporter testReporter) {
        testReporter.publishEntry("a key", "a value");
    }

    @Test
    void reportMultipleKeyValuePairs(TestReporter testReporter) {
        Map<String, String> values = new HashMap<>();
        values.put("user name", "dk38");
        values.put("award year", "1974");

        testReporter.publishEntry(values);
    }

}
```

_다른 파라미터 리졸버는 @ExtendWith어노테이션을 통해 적절한 추가기능을 등록 함으로서 명시적으로 사용 가능해진다._

사용자 정의 ParameterResolver의 예로 RandomParametersExtension를 보자. 
프로덕션 준비가 되어 있지는 않지만 확장 모델과 매개변수 해결 프로세스의 단순성과 표현력을 보여줍니다.
MyRandomParametersTest는 @Test 메소드에 랜덤 값을 주입하는 방법을 보여준다.

```java
@ExtendWith(RandomParametersExtension.class)
class MyRandomParametersTest {

    @Test
    void injectsInteger(@Random int i, @Random int j) {
        assertNotEquals(i, j);
    }

    @Test
    void injectsDouble(@Random double d) {
        assertEquals(0.0, d, 1.0);
    }

}
```
실제 사용되는 예로, MockitoExtension과 SpringExtension의 소스 코드를 확인하십시오.

주입할 파라미터 타입이 ParameterResolver의 유일한 조건인 경우, generic TypeBasedParameterResolver 기본 클래스를 사용할 수 있다.
supportsParameters 메소드는 백그라운드에서 구현되며, 파라미터화된 타입을 지원한다.


## 2.14. Test Interfaces and Default Methods
JUnit Jupiter 에서 는 @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, @TestTemplate, @BeforeEach 그리고 @AfterEach 어노테이션이 인터페이스의 default 메소드에 선언 가능하다.
테스트 인터페이스나 테스트클래스가 @TestInstance(Lifecycle.PER_CLASS)로 어노테이션 되어 있다면, @BeforeAll 과 @AfterAll 어노테이션은 테스트 인터페이스나 인터페이스의 default메소드의 static 메소드에 선언 될 수 있다.

```java
@TestInstance(Lifecycle.PER_CLASS)
interface TestLifecycleLogger {

    static final Logger logger = Logger.getLogger(TestLifecycleLogger.class.getName());

    @BeforeAll
    default void beforeAllTests() {
        logger.info("Before all tests");
    }

    @AfterAll
    default void afterAllTests() {
        logger.info("After all tests");
    }

    @BeforeEach
    default void beforeEachTest(TestInfo testInfo) {
        logger.info(() -> String.format("About to execute [%s]",
            testInfo.getDisplayName()));
    }

    @AfterEach
    default void afterEachTest(TestInfo testInfo) {
        logger.info(() -> String.format("Finished executing [%s]",
            testInfo.getDisplayName()));
    }

}
```

```java
interface TestInterfaceDynamicTestsDemo {

    @TestFactory
    default Stream<DynamicTest> dynamicTestsForPalindromes() {
        return Stream.of("racecar", "radar", "mom", "dad")
            .map(text -> dynamicTest(text, () -> assertTrue(isPalindrome(text))));
    }

}
```

@ExtendWith 와 @Tag 는 테스트 인터페이스에 선언 될 수 있다. 그 인터페이스를 구현한 클래스들에 자동적으로 태그와 확장기능을 상속 받는다.
```java
@Tag("timed")
@ExtendWith(TimingExtension.class)
interface TimeExecutionLogger {
}
```
테스트 클래스에서 TimeExecutionLogger 인터페이스를 구현하면 TimingExtension 확장기능과 timed 태그가 적용된다.

```java
//TimeExecutionLogger 외에도 TestLifecycleLogger, TestInterfaceDynamicTestsDemo 인터페이스를 구현하여, 각 인터페이스에 적용한 어노테이션들이 모두 적용된다.
class TestInterfaceDemo implements TestLifecycleLogger,
        TimeExecutionLogger, TestInterfaceDynamicTestsDemo {

    @Test
    void isEqualValue() {
        assertEquals(1, "a".length(), "is always equal");
    }

}
```

Object.equals 나 Comparable.compareTo 의 구현체가 어떻게 동작해야 하는지와 같은 인터페이스의 규약을 테스트 할 수 있다.

```java
public interface Testable<T> {

    T createValue();

}
```

```java
public interface EqualsContract<T> extends Testable<T> {

    T createNotEqualValue();

    @Test
    default void valueEqualsItself() {
        T value = createValue();
        assertEquals(value, value);
    }

    @Test
    default void valueDoesNotEqualNull() {
        T value = createValue();
        assertFalse(value.equals(null));
    }

    @Test
    default void valueDoesNotEqualDifferentValue() {
        T value = createValue();
        T differentValue = createNotEqualValue();
        assertNotEquals(value, differentValue);
        assertNotEquals(differentValue, value);
    }

}
```
```java
public interface ComparableContract<T extends Comparable<T>> extends Testable<T> {

    T createSmallerValue();

    @Test
    default void returnsZeroWhenComparedToItself() {
        T value = createValue();
        assertEquals(0, value.compareTo(value));
    }

    @Test
    default void returnsPositiveNumberWhenComparedToSmallerValue() {
        T value = createValue();
        T smallerValue = createSmallerValue();
        assertTrue(value.compareTo(smallerValue) > 0);
    }

    @Test
    default void returnsNegativeNumberWhenComparedToLargerValue() {
        T value = createValue();
        T smallerValue = createSmallerValue();
        assertTrue(smallerValue.compareTo(value) < 0);
    }

}
```

테스트 클래스에서 두개의 인터페이스를 구현하면, 상속받은 테스트들을 실행할 수 있다. 물론 추상 메소드를 구현해야 한다.
```java
class StringTests implements ComparableContract<String>, EqualsContract<String> {

    @Override
    public String createValue() {
        return "banana";
    }

    @Override
    public String createSmallerValue() {
        return "apple"; // 'a' < 'b' in "banana"
    }

    @Override
    public String createNotEqualValue() {
        return "cherry";
    }

}
```



## 2.15. Repeated Tests
@RepeatedTest 어노테이션에 반복하고 싶은 테스트 횟수를 지정함 으로서 테스트를 반복 실행하는 기능을 제공한다. 
반복 테스트의 각 실행은 일반적인 @Test 메소드가 실행되는 경우와 똑같은 라이프 사이클과 확장기능을 지원한다.

테스트를 10회 반복 수행하는 함수는 아래처럼 작성하면 된다.
```java
@RepeatedTest(10)
void repeatedTest() {
    // ...
}
```

JUnit Jupiter 5.10 이후, @RepeatedTest는 실패 임계값을 통해 임계값 이상 테스트가 실패 할 경우 남은 테스트를 자동으로 스킵하도록 설정 할 수 있다.
failureThreshold 속성값을 전체 반복 횟수보다 작은 양수로 설정하면, 지정된 실패 횟수가 발생한 후 남은 반복 횟수의 실행을 건너뛸 수 있다.

예로, @RepeatedTest를 사용해 실패하기 쉽다고 생각되는 테스트를 반복적으로 수행하는경우, 단일 실패는 테스트가 실패하기 쉽다는것을 보여주고 남은 반복을 수행할 필요가 없다. 이런 경우 failureThreshold 속성값을 1로 설정하면 된다.

기본으로, failureThreshold 속성값은 Integer.MAX_VALUE 로 설정되어 있어서, 실패 임계값이 적용되지 않는다. 즉, 지정된 반복 횟수는 실패 여부와 상관없이 실행된다.

_만약 @RepeatedTest 메소드가 병렬로 실행된다면, 실패 임계값에 대한 보장을 할 수 없다.
It is therefore recommended that a @RepeatedTest method be annotated with @Execution(SAME_THREAD) when parallel execution is configured.
그렇기 때문에 병렬 실행이 설정 된경우 @RepeatedTest 메소드에는 @Execution(SAME_THREAD) 어노테이션을 같이 사용하도록 추천한다._ 

반복횟수와 실패 임계값을 설정하는것 외에도, @RepeatedTest 어노테이션의 name 속성을 이용해서 각 반복 수행에 개별 display 이름을 지정할 수 있다. 
추가로, display 이름의 패턴은 정적 텍스트와 동적 플레이스 홀더의 조합으로 구성할 수 있다. 현재 지원하는 플레이스 홀더는 아래와 같다.
* {displayName}: @RepeatedTest 메소드의 display 이름
* {currentRepetition}: 현재 반복 수행 횟수
* {totalRepetitions}: 전체 반복 횟수

기본 display 이름은 다음과 같다.: "repetition {currentRepetition} of {totalRepetitions}".
따라서, 이전에 나왔던 repeatedTest()함수의 display 이름은 다음과 같이 표시된다.: repetition 1 of 10, repetition 2 of 10

@RepeatedTest 메소드의 display 이름에 각 반복 수행의 display 이름을 포함하고 싶다면, 사용자 정의 패턴 이용하거나, RepeatedTest.LONG_DISPLAY_NAME 패턴을 사용하면 된다.
RepeatedTest.LONG_DISPLAY_NAME 패턴 형식은 "{displayName} :: repetition {currentRepetition} of {totalRepetitions}" 와 같으며, 이는 repeatedTest() :: repetition 1 of 10, repeatedTest() :: repetition 2 of 10 와 같은 반복 수행의 display 이름을 생성한다.

현재 반복 수행, 전체 반복 횟수, 실패 횟수, 실패 임계치 등의 정보를 알고 싶다면 @RepeatedTest, @BeforeEach, @AfterEach 메소드에 RepetitionInfo 인스턴스를 주입 받아서 확인 할 수 있다.

### 2.15.1. Repeated Test Examples
섹션 후반부에 있는 RepeatedTestDemo 클래스는 반복 테스트의 여러 예제를 보여준다.
repeatedTest() 메소드는 이전 섹션의 예제와 동일하다. 반면, repeatedTestWithRepetitionInfo()는 반복 테스트의 총 반복 횟수에 접근하기 위해 RepetitionInfo 인스턴스를 테스트에 주입하는 방법을 보여준다.

repeatedTestWithFailureThreshold() 메소드는 실패 임계값을 설정하는 방법을 보여주고, 두번째 시행에 예상치 못한 실패를 시뮬레이션 한다.

섹션 후반부에 ConsoleLauncher로 실행 했을때의 결과를 작성 했다.

그 다음 두 메소드는 @RepeatedTest 메소드 각 반복에 display 이름을 작성할때 @DisplayName 어노테이션 값을 포함하는 방법을 보여준다. 
customDisplayName() 메소드는 사용자 정의 패턴으로에 사용자 지정 display 이름을 사용했고, TestInfo를 사용해서 생성된 display 이름의 형식을 검증 했다.
@DisplayName 어노테이션에 정의된 "Repeat!" 문자열은 {displayName}에 대응되고, 1/1은 {currentRepetition}/{totalRepetitions}에 대응된다.

이에 반해, customDisplayNameWithLongPattern() 메소드는 미리 정의된 RepeatedTest.LONG_DISPLAY_NAME 패턴을 사용한다.

repeatedTestInGerman() 메소드는 반복 수행 테스트의 display 이름을 외국어로 번역하는 기능을 보여준다(이 경우는 독일어). Wiederholung 1 von 5, Wiederholung 2 von 5 와 같은 반복 수행의 display 이름이 생성된다.

beforeEach() 메소드는 @BeforeEach 어노테이션이 사용되었기 때문에 각 반복 테스트의 실행 전에 실행된다.

TestInfo와 RepetitionInfo를 메소드에 주입함에 따라 현재 실행중인 반복 테스트에 대한 정보를 얻을 수 있다.
RepeatedTestsDemo를 INFO 로그 레벨로 실행하면 다음과 같은 결과를 확인 할 수 있다.
```text
INFO: About to execute repetition 1 of 10 for repeatedTest
INFO: About to execute repetition 2 of 10 for repeatedTest
INFO: About to execute repetition 3 of 10 for repeatedTest
INFO: About to execute repetition 4 of 10 for repeatedTest
INFO: About to execute repetition 5 of 10 for repeatedTest
INFO: About to execute repetition 6 of 10 for repeatedTest
INFO: About to execute repetition 7 of 10 for repeatedTest
INFO: About to execute repetition 8 of 10 for repeatedTest
INFO: About to execute repetition 9 of 10 for repeatedTest
INFO: About to execute repetition 10 of 10 for repeatedTest
INFO: About to execute repetition 1 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 2 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 3 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 4 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 5 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 1 of 8 for repeatedTestWithFailureThreshold
INFO: About to execute repetition 2 of 8 for repeatedTestWithFailureThreshold
INFO: About to execute repetition 3 of 8 for repeatedTestWithFailureThreshold
INFO: About to execute repetition 4 of 8 for repeatedTestWithFailureThreshold
INFO: About to execute repetition 1 of 1 for customDisplayName
INFO: About to execute repetition 1 of 1 for customDisplayNameWithLongPattern
INFO: About to execute repetition 1 of 5 for repeatedTestInGerman
INFO: About to execute repetition 2 of 5 for repeatedTestInGerman
INFO: About to execute repetition 3 of 5 for repeatedTestInGerman
INFO: About to execute repetition 4 of 5 for repeatedTestInGerman
INFO: About to execute repetition 5 of 5 for repeatedTestInGerman
```

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.fail;

import java.util.logging.Logger;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.RepetitionInfo;
import org.junit.jupiter.api.TestInfo;

class RepeatedTestsDemo {

    private Logger logger = // ...

    @BeforeEach
    void beforeEach(TestInfo testInfo, RepetitionInfo repetitionInfo) {
        int currentRepetition = repetitionInfo.getCurrentRepetition();
        int totalRepetitions = repetitionInfo.getTotalRepetitions();
        String methodName = testInfo.getTestMethod().get().getName();
        logger.info(String.format("About to execute repetition %d of %d for %s", //
            currentRepetition, totalRepetitions, methodName));
    }

    @RepeatedTest(10)
    void repeatedTest() {
        // ...
    }

    @RepeatedTest(5)
    void repeatedTestWithRepetitionInfo(RepetitionInfo repetitionInfo) {
        assertEquals(5, repetitionInfo.getTotalRepetitions());
    }

    @RepeatedTest(value = 8, failureThreshold = 2)
    void repeatedTestWithFailureThreshold(RepetitionInfo repetitionInfo) {
        // Simulate unexpected failure every second repetition
        if (repetitionInfo.getCurrentRepetition() % 2 == 0) {
            fail("Boom!");
        }
    }

    @RepeatedTest(value = 1, name = "{displayName} {currentRepetition}/{totalRepetitions}")
    @DisplayName("Repeat!")
    void customDisplayName(TestInfo testInfo) {
        assertEquals("Repeat! 1/1", testInfo.getDisplayName());
    }

    @RepeatedTest(value = 1, name = RepeatedTest.LONG_DISPLAY_NAME)
    @DisplayName("Details...")
    void customDisplayNameWithLongPattern(TestInfo testInfo) {
        assertEquals("Details... :: repetition 1 of 1", testInfo.getDisplayName());
    }

    @RepeatedTest(value = 5, name = "Wiederholung {currentRepetition} von {totalRepetitions}")
    void repeatedTestInGerman() {
        // ...
    }

}
```

유니코드 테마가 가능한 ConsoleLauncher를 사용하면 RepeatedTestsDemo의 실행 결과는 다음과 같다.
```text
├─ RepeatedTestsDemo ✔
│  ├─ repeatedTest() ✔
│  │  ├─ repetition 1 of 10 ✔
│  │  ├─ repetition 2 of 10 ✔
│  │  ├─ repetition 3 of 10 ✔
│  │  ├─ repetition 4 of 10 ✔
│  │  ├─ repetition 5 of 10 ✔
│  │  ├─ repetition 6 of 10 ✔
│  │  ├─ repetition 7 of 10 ✔
│  │  ├─ repetition 8 of 10 ✔
│  │  ├─ repetition 9 of 10 ✔
│  │  └─ repetition 10 of 10 ✔
│  ├─ repeatedTestWithRepetitionInfo(RepetitionInfo) ✔
│  │  ├─ repetition 1 of 5 ✔
│  │  ├─ repetition 2 of 5 ✔
│  │  ├─ repetition 3 of 5 ✔
│  │  ├─ repetition 4 of 5 ✔
│  │  └─ repetition 5 of 5 ✔
│  ├─ repeatedTestWithFailureThreshold(RepetitionInfo) ✔
│  │  ├─ repetition 1 of 8 ✔
│  │  ├─ repetition 2 of 8 ✘ Boom!
│  │  ├─ repetition 3 of 8 ✔
│  │  ├─ repetition 4 of 8 ✘ Boom!
│  │  ├─ repetition 5 of 8 ↷ Failure threshold [2] exceeded
│  │  ├─ repetition 6 of 8 ↷ Failure threshold [2] exceeded
│  │  ├─ repetition 7 of 8 ↷ Failure threshold [2] exceeded
│  │  └─ repetition 8 of 8 ↷ Failure threshold [2] exceeded
│  ├─ Repeat! ✔
│  │  └─ Repeat! 1/1 ✔
│  ├─ Details... ✔
│  │  └─ Details... :: repetition 1 of 1 ✔
│  └─ repeatedTestInGerman() ✔
│     ├─ Wiederholung 1 von 5 ✔
│     ├─ Wiederholung 2 von 5 ✔
│     ├─ Wiederholung 3 von 5 ✔
│     ├─ Wiederholung 4 von 5 ✔
│     └─ Wiederholung 5 von 5 ✔
```


## 2.16. Parameterized Tests
Parameterized 테스트는 매번 다른 인자들을 사용하여 여러번 테스트를 수행 할 수 있게 해준다.
@Test 어노테이션 대신 @ParameterizedTest 어노테이션을 사용하면 된다.
그리고 테스트가 수행 될 때마다 사용될 하나 이상의 소스를 정의 하면, 테스트 메소드에서 인자를 사용하게 된다.

아래 예는 @ValueSource 어노테이션을 이용하여 스트링 배열을 인자의 소스로 사용한 parameterized 테스트를 보여준다.
```java
@ParameterizedTest
@ValueSource(strings = { "racecar", "radar", "able was I ere I saw elba" })
void palindromes(String candidate) {
    assertTrue(StringUtils.isPalindrome(candidate));
}
```
위 parameterized 테스트 메소드를 실행하면, 각 실행들은 개별로 결과가 표시된다. 예를 들어, ConsoleLauncher는 다음과 같은 결과를 출력한다.
```text
palindromes(String) ✔
├─ [1] candidate=racecar ✔
├─ [2] candidate=radar ✔
└─ [3] candidate=able was I ere I saw elba ✔
```

### 2.16.1. Required Setup
parameterized 테스트를 사용하기 위해서는 junit-jupiter-params 의존성을 추가해야 한다.

10.2. Dependency Metadata 를 참고 하자.

### 2.16.2. Consuming Arguments
Parameterized 테스트 메소드는 일반적으로 설정된 소스로 부터 인자를 직접 사용한다. 인자 소스의 인덱스와 메소드 파라미터의 인덱스는 서로 일대일 대응이다.
parameterized 테스트 메소드는 소스의 인자들을 이용해 단일 오브젝트를 생성하고 이를 메소드에 전달 할 수도 있다.
ParameterResolver 를 통해 추가적인 인자를 제공 할 수도 있다. (예, TestInfo, TestReporter)
특별히, parameterized 테스트 메소드는 다음 규칙에 따라 파라미터를 정의해야 한다.

* 0개 이상의 인덱스된 인자들이 먼저 선언되어야 한다.
* 0개 이상의 aggregator들이 다음에 선언되어야 한다.
* 0개 이상의 ParameterResolver에 의해 제공되는 인자들은 마지막에 선언되어야 한다.

인덱스된 인자는 ArgumentsProvider로 부터 인덱스를 부여받은 인자들이다. 인덱스된 인자들은 메소드의 파라미터 리스트의 같은 인덱스에 위치한 parameterized 메소드의 인자로 전달된다.(말이 어렵네 아래 내용들을 보면서 자세히 파악하는게 좋아보임)
aggregator는 ArgumentsAccesor 타입의 파라미터나 @AggregateWith 어노테이션을 사용한 파라미터이다.

>_**AutoCloseable arguments**_  
> java.lang.AutoCloseable(또는 java.lang.AutoCloseable를 상속받은 java.io.Closeable)를 구현한 인자는 @AfterEach 메소드와  AfterEachCallback이 실행된 후 close 된다. 
> 이것을 방지하기 위해서는, @ParameterizedTest 어노테이션의 autoCloseArguments 속성을 false 로 설정하면된다. 특별히 만약 AutoCloseable을 구현한 인자가 parameterized 테스트 메소드의 여러 실행에 재사용되면, 인자가 실행 사이에 닫히지 않도록 하기 위해 @ParameterizedTest(autoCloseArguments = false)로 메소드에 어노테이션을 해야 한다.


### 2.16.3. Sources of Arguments
여러 소스 어노테이션들이 제공되고, 아래 내용을 통해 각각에 대한 개요와 간단한 예제를 살펴 볼 수 있다. 
org.junit.jupiter.params.provider 패키지의 Javadoc을 확인하여 추가 정보를 확인 할 수 있다.

#### @ValueSource  
@ValueSource 는 가장 간단한 소스 중 하나이다. 이 어노테이션은 테스트당 1개의 기본타입의 값들도 되어있는 배열이나 1개의 인자를 제공한다. 

아래 타입들이 @ValueSource 어노테이션에서 지원하는 기본타입 이다.
* short
* byte
* int
* long
* float
* double
* char
* boolean
* java.lang.String
* java.lang.Class

아래의 예처럼 @ParameterizedTest 메소드는 각각 1, 2, 3의 값을 가지고 세번 실행된다.
```java
@ParameterizedTest
@ValueSource(ints = { 1, 2, 3 })
void testWithValueSource(int argument) {
    assertTrue(argument > 0 && argument < 4);
}
```

#### Null and Empty Sources
잘못된 값이 입력되었을 때를 테스트 하기 위해 parameterized 테스트에 널이나 빈 값을 제공하는 것은 유용하다. 
아래 어노테이션들을 이용해서 parameterized 테스트에 null 과 빈 값을 제공할 수 있다.  

* @NullSource: @ParameterizedTest 메소드에 하나의 null 인자를 제공한다.
  * @NullSource 는 기본타입(primitive type)에 사용 할 수 없다.
* @EmptySource: @ParameterizedTest 메소드에 하나의 빈 인자를 제공한다. 
  * 파라미터로 올 수 있는 타입은 다음과 같다: java.lang.String, java.util.Collection (그리고 기본(매개변수 없는) 생성자를 가진 구현체 subtype), java.util.List, java.util.Set, java.util.SortedSet, java.util.NavigableSet, java.util.Map (그리고 기본(매개변수 없는) 생성자를 가진 구현체 subtype), java.util.SortedMap, java.util.NavigableMap, 기본(primitive) 타입의 배열 (e.g., int[], char[][], etc.), object arrays (e.g., String[], Integer[][], etc.).
* @NullAndEmptySource: @NullSource and @EmptySource 어노테이션의 기능을 모두 포함한다.

빈 문자열을 표현하는 다양한 타입들을 테스트 해야 한다면, @ValueSource(strings = {" ", "   ", "\t", "\n"})와 같이 작성하면 된다.
아래 예제 처럼 @NullSource, @EmptySource 어노테이션과 같이 사용하면 null 값과 빈 값도 테스트 가능 하다. 

```java
@ParameterizedTest
@NullSource
@EmptySource
@ValueSource(strings = { " ", "   ", "\t", "\n" })
void nullEmptyAndBlankStrings(String text) {
    assertTrue(text == null || text.trim().isEmpty());
}
```
위 예제를 @NullAndEmptySource 어노테이션을 이용해 아래처럼 조금더 간단하게 작성 할수 있다.

```java
@ParameterizedTest
@NullAndEmptySource
@ValueSource(strings = { " ", "   ", "\t", "\n" })
void nullEmptyAndBlankStrings(String text) {
    assertTrue(text == null || text.trim().isEmpty());
}
```
> 위 테스트를 수행하면 모두 null 1번, empty string 1번, 그리고 @ValueScource로 입력받은 4개의 스트링을 테스트 하기 때문에 총 6번의 테스트가 수행된다.

#### @EnumSource
@EnumSource 어노테이션은 Enum 타입을 제공할때 편리한 방법을 제공한다.

```java
@ParameterizedTest
@EnumSource(ChronoUnit.class)
void testWithEnumSource(TemporalUnit unit) {
    assertNotNull(unit);
}
```
@EnumSource 어노테이션의 value 속성은 생략 가능하다. 생략된다면, 메소드의 첫번째 파라미터의 타입이 사용된다. 첫번째 파라미터 타입이 enum 타입이 아니면 테스트는 실패로 끝난다.
따라서, 위 예제에서는 메소드의 첫번째 파라미터가 TemporalUnit(인터페이스 타입)이기 때문에 value 속성이 꼭 필요하다.
만약 파라미터 타입을 ChronoUnit로 변경한다면 아래와 같이 어노테이션에서 enum 타입을 생략 할 수 있다.
```java
@ParameterizedTest
@EnumSource
void testWithEnumSourceWithAutoDetection(ChronoUnit unit) {
    assertNotNull(unit);
}
```
name 속성을 선택적으로 입력할 수 있다. 이 속성은 아래와 같이 사용할 enum 상수를 지정할 수 있다. 생략하면 모든 상수가 사용된다.
```java
@ParameterizedTest
@EnumSource(names = { "DAYS", "HOURS" })
void testWithEnumSourceInclude(ChronoUnit unit) {
    assertTrue(EnumSet.of(ChronoUnit.DAYS, ChronoUnit.HOURS).contains(unit));
}
````

mode 속성을 선택적으로 입력할 수 있다. 이 속성은 테스트 메소드에 전달하는 상수의 세밀한 제어를 가능하게 한다.
For example, you can exclude names from the enum constant pool or specify regular expressions as in the following examples.
예로, enum 에서 제외할 상수들을 지정한다거나, 아래 예 처럼 정규표현식을 사용 할 수도 있다.
```java

```java
@ParameterizedTest
@EnumSource(mode = EXCLUDE, names = { "ERAS", "FOREVER" })
void testWithEnumSourceExclude(ChronoUnit unit) {
    assertFalse(EnumSet.of(ChronoUnit.ERAS, ChronoUnit.FOREVER).contains(unit));
}
```
```java
@ParameterizedTest
@EnumSource(mode = MATCH_ALL, names = "^.*DAYS$")
void testWithEnumSourceRegex(ChronoUnit unit) {
    assertTrue(unit.name().endsWith("DAYS"));
}
```

#### @MethodSource
@MethodSource는 테스트 클래스나 외부 클래스의 하나 이상의 팩토리 메소드를 참조 할 수 있게 해준다.
테스트 클래스 내부의 팩토리 메소드는 테스트 클래스가 @TestInstance(Lifecycle.PER_CLASS)로 정의되지 않은 이상 static 이어야 한다. 외부 클래스의 팩토리 메소드는 언제나 static 으로 선언되어 있어야 한다.

팩토리 메소드는 인자들의 스트림을 생성해야한다. 그리고 스트림내의 각 인자들은 @ParameterizedTest 메소드가 실행될때 인자로 사용된다.

일반적으로, 인자의 스트림이라고 말하지만 실제로는 다양한 타입을 사용 할 수 있다.
이 글에서, "스트림"은 JUnit이 Stream으로 변환할 수 있는 모든것을 의미한다. 예로, Stream, DoubleStream, LongStream, IntStream, Collection, Iterator, Iterable, 객체의 배열, primitive 타입의 배열 등이 있다.
parameterized 테스트가 단일 인자만 수용하도록 작성되어 있다면 스트림 내의 인자는 object의 배열과 같은 인자의 객체를 제공 할 수 있다.

단일 파라미터만 필요하다면 아래 예제처럼 파라미터 타입의 인스턴스 스트림을 반환 할 수 있다.
```java
@ParameterizedTest
@MethodSource("stringProvider")
void testWithExplicitLocalMethodSource(String argument) {
    assertNotNull(argument);
}

static Stream<String> stringProvider() {
    return Stream.of("apple", "banana");
}
```

@MethodSource 어노테이션에 팩토리 메소드를 명시적으로 지정하지 않으면, JUnit은 @ParameterizedTest 메소드명과 똑같은 이름의 팩토리 메소드를 찾는다. 아래 예제를 보자.
```java
@ParameterizedTest
@MethodSource
void testWithDefaultLocalMethodSource(String argument) {
    assertNotNull(argument);
}

static Stream<String> testWithDefaultLocalMethodSource() {
    return Stream.of("apple", "banana");
}
```
아래 예 것 처럼 primitive 타입 스트림들도 지원한다.
```java
@ParameterizedTest
@MethodSource("range")
void testWithRangeMethodSource(int argument) {
    assertNotEquals(9, argument);
}

static IntStream range() {
    return IntStream.range(0, 20).skip(10);
}
```
만약 parameterized 테스트 메소드에 여러개의 파라미터가 필요하다면, Arguments 인스턴스의 collection, stream, 배열을 반환하거나, 아래 예제 처럼 오브젝트 배열을 반환해야 한다. (더 다양한 리턴타입이 궁금하다면, @MethodSource Javadoc을 보자)

Note that arguments is a static factory method defined in the Arguments interface.
아래 예제에서 arguments(Object...)는 Arguments 인터페이스에 정의된 static factory 메소드이다.
arguments(Object...) 대신에 Arguments.of(Object…)를 사용 할 수도 있다.
```java
@ParameterizedTest
@MethodSource("stringIntAndListProvider")
void testWithMultiArgMethodSource(String str, int num, List<String> list) {
    assertEquals(5, str.length());
    assertTrue(num >=1 && num <=2);
    assertEquals(2, list.size());
}

static Stream<Arguments> stringIntAndListProvider() {
    return Stream.of(
        arguments("apple", 1, Arrays.asList("a", "b")),
        arguments("lemon", 2, Arrays.asList("x", "y"))
    );
}
```
An external, static factory method can be referenced by providing its fully qualified method name as demonstrated in the following example.
외부 static 팩토리 메소드는 아래 예제처럼 전체 메소드 이름을 지정해서 참조 할 수 있다.
```java
package example;

import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

class ExternalMethodSourceDemo {

    @ParameterizedTest
    @MethodSource("example.StringsProviders#tinyStrings")
    void testWithExternalMethodSource(String tinyString) {
        // test with tiny string
    }
}

class StringsProviders {

    static Stream<String> tinyStrings() {
        return Stream.of(".", "oo", "OOO");
    }
}
```
팩토리 메소드는 파라미터를 선언할 수 있고, 이 파라미터는 ParameterResolver 확장 API 를 구현한 구현체를 등록하고, 이로부터 제공 받을 수 있다. 
아래 예에서, 팩토리 메소드는 테스트 클래스에 하나만 있기 때문에 이름으로 참조된다.
만약 이름이 같은 로컬 메소드들이 여러개 있다면, @MethodSource("factoryMethod()"), @MethodSource("factoryMethod(java.lang.String)") 와 같이 파라미터로 구분 할 수 있다.
@MethodSource("example.MyTests#factoryMethod(java.lang.String)") 와 같이 전체 메소드 이름으로도 참조 할 수 있다.
```java
@RegisterExtension
static final IntegerResolver integerResolver = new IntegerResolver();

@ParameterizedTest
@MethodSource("factoryMethodWithArguments")
void testWithFactoryMethodWithArguments(String argument) {
    assertTrue(argument.startsWith("2"));
}

static Stream<Arguments> factoryMethodWithArguments(int quantity) {
    return Stream.of(
            arguments(quantity + " apples"),
            arguments(quantity + " lemons")
    );
}

static class IntegerResolver implements ParameterResolver {

    @Override
    public boolean supportsParameter(ParameterContext parameterContext,
            ExtensionContext extensionContext) {

        return parameterContext.getParameter().getType() == int.class;
    }

    @Override
    public Object resolveParameter(ParameterContext parameterContext,
            ExtensionContext extensionContext) {

        return 2;
    }

}
```

#### @CsvSource
@CsvSource는 쉼표로 구분된 값들의 목록을 표현 할 수 있게 해준다. (예, CSV 문자열 리터럴)
@CsvSource의 속성으로 작성한 각 문자열은 CSV 레코드 형태로 작성되고, parameterized 테스트가 실행될 때 사용된다.
useHeadersInDisplayName 속성값을 통해서 첫번째 행은 헤더로 사용할 수 도 있다. (세부사항과 예제는 Javadoc의 useHeadersInDisplayName 속성을 참고하자)
```java
@ParameterizedTest
@CsvSource({
    "apple,         1",
    "banana,        2",
    "'lemon, lime', 0xF1",
    "strawberry,    700_000"
})
void testWithCsvSource(String fruit, int rank) {
    assertNotNull(fruit);
    assertNotEquals(0, rank);
}
```

기본 구분 문자는 쉼포 이다. 하지만 다른 문자를 사용하고 싶다면 delimiter 속성을 사용하면 된다.
delimiterString 속성을 이용하여 단일 문자 대신 문자열을 구분자로 사용 할 수도 있다. 그러나, 동시에 두종류를 사용 할수는 없다.

기본적으로 @CsvSource는 작은 따옴표(')를 문자열을 묶는 따옴표로 사용한다. 하지만 quoteCharacter 속성을 이용하여 변경 할 수 있다. (위 예제나 아래 테이블에서 'lemon, lime')
빈 값 ('')은 emptyValue 속성이 설정되지 않은 한 빈 문자열로 해석된다. 반면, 완전히 비어있는 값은 null 참조로 인식 된다.
하나 이상의 nullValues를 특정하면, 해당 값은 null 로 인식 된다. (아래 표에 NIL 예제를 보라)
null이 기본(primitive) 타입에 사용된다면 ArgumentConversionException이 발생한다.

> nullValues 속성에 어떤 값이 지정되었다 하더라도, 따옴표가 없이 빈 값은 언제나 null 값으로 변경된다.

따옴포 내부에서 처음이나 마지막에 빈 공백이 입력되면 자동으로 공백이 제거(trim)된다. ignoreLeadingAndTrailingWhitespace 속성값을 통해서 이 동작을 변경 할 수 있다.

|Example Input|Resulting Argument List|
|---|---|
|@CsvSource({ "apple, banana" })|"apple", "banana"|
|@CsvSource({ "apple, 'lemon, lime'" })|"apple", "lemon, lime"|
|@CsvSource({ "apple, ''" })|"apple", ""|
|@CsvSource({ "apple, " })|"apple", null|
|@CsvSource(value = { "apple, banana, NIL" }, nullValues = "NIL")|"apple", "banana", null|
|@CsvSource(value = { " apple , banana" }, ignoreLeadingAndTrailingWhitespace = false)|" apple ", " banana"|

프로그래밍 언어에서 텍스트 블록(Java 15 이상)을 지원하는 경우, @CsvSource의 textBlock 속성을 사용할 수도 있다.
텍스트 블록의 각 행은 CSV 레코드를 나타내고, parameterized 테스트가 실행될 때 사용된다.
아래 예 처럼 useHeadersInDisplayName 속성값을 true로 로 설정하여 첫번째 행을 헤더로 사용할 수 있다.

텍스트 블록을 이용하여 위 예제를 다음과 같이 구현 할 수도 있다.
```java
@ParameterizedTest(name = "[{index}] {arguments}")
@CsvSource(useHeadersInDisplayName = true, textBlock = """
    FRUIT,         RANK
    apple,         1
    banana,        2
    'lemon, lime', 0xF1
    strawberry,    700_000
    """)
void testWithCsvSource(String fruit, int rank) {
    // ...
}
```
위 예제의 CSV 헤더를 포함한 display 이름은 다음과 같이 생성된다.
```text
[1] FRUIT = apple, RANK = 1
[2] FRUIT = banana, RANK = 2
[3] FRUIT = lemon, lime, RANK = 0xF1
[4] FRUIT = strawberry, RANK = 700_000
```
CSV 레코드를 value 속성으로 제공하는 경우와 달리 텍스트 블록은 주석을 포함시킬 수 있다. 
"#" 기호로 시작하는 줄은 주석으로 처리되어 무시 된다. "#"기호는 줄의 첫번째 문자 이어야 하며 그 앞에 어떠한 공백도 있어서는 안된다.
블록 문을 닫는 기호(""")는 마지막 라인의 끝에 작성하거나 그 다음라인에 왼쪽 정렬하여 작성하는 것이 좋다. (아래 예제에서 볼 수 있듯이 테이블과 비슷한 형식으로 포맷팅을 보여준다.) 
```java
@ParameterizedTest
@CsvSource(delimiter = '|', quoteCharacter = '"', textBlock = """
    #-----------------------------
    #    FRUIT     |     RANK
    #-----------------------------
         apple     |      1
    #-----------------------------
         banana    |      2
    #-----------------------------
      "lemon lime" |     0xF1
    #-----------------------------
       strawberry  |    700_000
    #-----------------------------
    """)
void testWithCsvSource(String fruit, int rank) {
    // ...
}
```

> Java의 텍스트 블럭 기능은 컴파일 시 자동으로 의도하지 않은 공백을 제거한다.
> 하지만 Groovy나 Kotlin과 같은 다른 JVM 언어는 자동으로 공백을 제거하지 않는다.
> 따라서, 만약 Java가 아닌 다른 프로그래밍 언어를 사용하고 있다면, 블럭 문자열을 작성할때 문자열 앞에 공백이 오지 않게 주의 해야 한다. 

#### @CsvFileSource
@CsvFileSource 어노테이션은 클래스 패스나 로컬 파일 시스템의 CSV 파일을 사용 할 수 있도록 해준다.
CSV 파일의 각 행들은 parameterized 테스트가 실행될 때 사용된다.
첫번째 레코드는 헤더로 사용 될 수도 있다. numLinesToSkip 속성을 통해 헤더라인을 무시할 수 있다.
헤더를 display 이름으로 사용하고 싶다면, useHeadersInDisplayName 속성을 true로 설정 해야 한다.
아래 예제는 numLinesToSkip 와 useHeadersInDisplayName의 사용법을 보여준다.

The default delimiter is a comma (,), but you can use another character by setting the delimiter attribute.
기본 구분 문자는 쉼포 이지만 delimiter 속성을 통해 다른 문자를 사용 할 수 있다. 단일 문자 뿐만 아니라 delimiterString 속성을 통해 문자열을 구분자로 사용 할 수도 있다.
delimiter 속성과 delimiterString 속성은 동시에 사용 할 수 없다.
> _Comments in CSV files_  
> 라인이 #으로 시작하면 주석으로 인식 되어 무시된다.

```java
@ParameterizedTest
@CsvFileSource(resources = "/two-column.csv", numLinesToSkip = 1)
void testWithCsvFileSourceFromClasspath(String country, int reference) {
    assertNotNull(country);
    assertNotEquals(0, reference);
}

@ParameterizedTest
@CsvFileSource(files = "src/test/resources/two-column.csv", numLinesToSkip = 1)
void testWithCsvFileSourceFromFile(String country, int reference) {
    assertNotNull(country);
    assertNotEquals(0, reference);
}

@ParameterizedTest(name = "[{index}] {arguments}")
@CsvFileSource(resources = "/two-column.csv", useHeadersInDisplayName = true)
void testWithCsvFileSourceAndHeaders(String country, int reference) {
    assertNotNull(country);
    assertNotEquals(0, reference);
}
```
_two-column.csv_
```text
COUNTRY, REFERENCE
Sweden, 1
Poland, 2
"United States of America", 3
France, 700_000
```

아래 결과는 첫번째 두 테스트 메소드의 display 이름을 보여준다.
```text
[1] country=Sweden, reference=1
[2] country=Poland, reference=2
[3] country=United States of America, reference=3
[4] country=France, reference=700_000
```

아래 예제는 CSV 헤더 이름을 사용하는 마지막 parameterized 테스트 메소드의 생성된 display 이름을 보여준다.
```text
[1] COUNTRY = Sweden, REFERENCE = 1
[2] COUNTRY = Poland, REFERENCE = 2
[3] COUNTRY = United States of America, REFERENCE = 3
[4] COUNTRY = France, REFERENCE = 700_000
```
@CsvSource 어노테이션과는 다르게 @CsvFileSource 어노테이션에는 쌍따옴표(")가 문자열을 표시하는 문자이다. 이 역시 quoteCharacter 속성을 통해 변경 할 수 있다. 위 예에서 "United States of America" 를 보자.
비어있는 따옴표 값("") 은 emptyValue 속성이 설정되지 않은 한 빈 문자열로 해석된다. 반면, 완전히 비어있는 값은 null 값으로 해석 된다.
하나 이상의 nullValues 값을 지정하면 지정한 값이 null 로 인식 된다. nullValues에 기본(primitive)타입이 사용된다면 ArgumentConversionException이 발생한다.

> 따옴표 없이 빈 값은 nullValues 속성값과 관계 없이 언제나 null 로 인식된다.

따옴포 내부에서 처음이나 마지막에 빈 공백이 입력되면 자동으로 공백이 제거(trim)된다. ignoreLeadingAndTrailingWhitespace 속성값을 통해서 이 동작을 변경 할 수 있다.

#### @ArgumentsSource
@ArgumentsSource 어노테이션을 통해 ArgumentsProvider를 특정 할 수 있다.
ArgumentsProvider의 구현체는 top-level 클래스 또는 static nested 클래스로 선언되어야 한다는 것을 주의하자.

```java
@ParameterizedTest
@ArgumentsSource(MyArgumentsProvider.class)
void testWithArgumentsSource(String argument) {
    assertNotNull(argument);
}
```
```java
public class MyArgumentsProvider implements ArgumentsProvider {

    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of("apple", "banana").map(Arguments::of);
    }
}
```
ValueArgumentsProvider 나 CsvArgumentsProvider와 같이 어노테이션을 사용하는 ArgumentsProvider를 구현하고 싶다면, AnnotationBasedArgumentsProvider 클래스를 확장 해야 한다.

### 2.16.4. Argument Conversion
#### Widening Conversion
JUnit Jupiter은 확장 기본 타입 인자를 제공하기 위한 기능을 제공 한다. @ValueSource(ints = { 1, 2, 3 }) 와 같이 작성한다면, int 뿐 아니라 long, float, double 타입의 인자도 받을 수 있다.

#### Implicit Conversion
@CsvSource와 같은 사용 사례를 지원하기 위해, JUnit Jupiter는 몇가지 내장된 암시적 타입 컨버터를 제공한다. 변환 방법은 메소드 파라미터의 선언된 타입에 따라 달라진다.
@ParameterizedTest 메소드의 파라미터가 TimeUnit으로 선언되어 있고, 실제로는 String 타입의 인자가 제공된다면, String은 자동으로 TimeUnit enum 상수로 변환된다.  
```java
@ParameterizedTest
@ValueSource(strings = "SECONDS")
void testWithImplicitArgumentConversion(ChronoUnit argument) {
assertNotNull(argument.name());
}
```
String 객체는 아래 표에 보이는 것 처럼 암시적으로 형 변환된다.
> Decimal, 16진수, 8진수 문자열은 byte, short, int, long, 그리고 그 박싱된 타입으로 변환된다.

|Target Type|Example|
|---|---|
|boolean/Boolean|"true" → true (only accepts values 'true' or 'false', case-insensitive)|
|byte/Byte|"15", "0xF", or "017" → (byte) 15|
|char/Character|"o" → 'o'|
|short/Short|"15", "0xF", or "017" → (short) 15|
|int/Integer|"15", "0xF", or "017" → 15|
|long/Long|"15", "0xF", or "017" → 15L|
|float/Float|"1.0" → 1.0f|
|double/Double|"1.0" → 1.0d|
|Enum subclass|"SECONDS" → TimeUnit.SECONDS|
|java.io.File|"/path/to/file" → new File("/path/to/file")|
|java.lang.Class|"java.lang.Integer" → java.lang.Integer.class (use $ for nested classes, e.g. "java.lang.Thread$State")|
|java.lang.Class|"byte" → byte.class (primitive types are supported)|
|java.lang.Class|"char[]" → char[].class (array types are supported)|
|java.math.BigDecimal|"123.456e789" → new BigDecimal("123.456e789")|
|java.math.BigInteger|"1234567890123456789" → new BigInteger("1234567890123456789")|
|java.net.URI|"https://junit.org/" → URI.create("https://junit.org/")|
|java.net.URL|"https://junit.org/" → URI.create("https://junit.org/").toURL()|
|java.nio.charset.Charset|"UTF-8" → Charset.forName("UTF-8")|
|java.nio.file.Path|"/path/to/file" → Paths.get("/path/to/file")|
|java.time.Duration|"PT3S" → Duration.ofSeconds(3)|
|java.time.Instant|"1970-01-01T00:00:00Z" → Instant.ofEpochMilli(0)|
|java.time.LocalDateTime|"2017-03-14T12:34:56.789" → LocalDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000)|
|java.time.LocalDate|"2017-03-14" → LocalDate.of(2017, 3, 14)|
|java.time.LocalTime|"12:34:56.789" → LocalTime.of(12, 34, 56, 789_000_000)|
|java.time.MonthDay|"--03-14" → MonthDay.of(3, 14)|
|java.time.OffsetDateTime|"2017-03-14T12:34:56.789Z" → OffsetDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)|
|java.time.OffsetTime|"12:34:56.789Z" → OffsetTime.of(12, 34, 56, 789_000_000, ZoneOffset.UTC)|
|java.time.Period|"P2M6D" → Period.of(0, 2, 6)|
|java.time.YearMonth|"2017-03" → YearMonth.of(2017, 3)|
|java.time.Year|"2017" → Year.of(2017)|
|java.time.ZonedDateTime|"2017-03-14T12:34:56.789Z" → ZonedDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)|
|java.time.ZoneId|"Europe/Berlin" → ZoneId.of("Europe/Berlin")|
|java.time.ZoneOffset|"+02:30" → ZoneOffset.ofHoursMinutes(2, 30)|
|java.util.Currency|"JPY" → Currency.getInstance("JPY")|
|java.util.Locale|"en" → new Locale("en")|
|java.util.UUID|"d043e930-7b3b-48e3-bdbe-5a3ccfb833db" → UUID.fromString("d043e930-7b3b-48e3-bdbe-5a3ccfb833db")|

#### Fallback String-to-Object Conversion
스트링에서 위 표에 열거된 대상 타입으로 암시적 형변환 외에도, 명시적 형 변환을 위한 팩토리 메소드나 팩토리 생성자가 정의 된 경우, 스트링에서 대상 타입으로 형변환 하는 대체 메커니즘을 제공한다.
* 팩토리 메소드: private 이 아닌 static 메소드로 선언되어 있고, 단일 String 파라미터를 받아 대상 타입 인스턴스를 반환해야 한다. 메소드 명은 임의로 지정 할 수 있으며, 따라야 하는 다른 규칙은 없다.
* 팩토리 생성자: 대상 타입의 private 생성자여서는 안되고, 단일 String 인자를 받아야 한다. 대상 타입은 반드시 top-level 클래스 또는 static nested 클래스로 선언되어야 한다. 

> 여러개의 팩토리 메소드가 발견되면 모두 무시된다. 팩토리 메소드와 팩토리 생성자가 하나씩 있다면, 팩토리 메소드가 생성자 대신 사용된다.

아래의 @ParameterizedTest 메소드에서 Book 인자는 Book.fromTitle(String) 팩토리 메소드를 호출하여 "42 Cats"를 책의 제목으로 전달하여 생성된다.
```java
@ParameterizedTest
@ValueSource(strings = "42 Cats")
void testWithImplicitFallbackArgumentConversion(Book book) {
    assertEquals("42 Cats", book.getTitle());
}
```
```java
public class Book {

    private final String title;

    private Book(String title) {
        this.title = title;
    }

    public static Book fromTitle(String title) {
        return new Book(title);
    }

    public String getTitle() {
        return this.title;
    }
}
```

#### Explicit Conversion
Instead of relying on implicit argument conversion you may explicitly specify an ArgumentConverter to use for a certain parameter using the @ConvertWith annotation like in the following example.
Note that an implementation of ArgumentConverter must be declared as either a top-level class or as a static nested class.
```java
@ParameterizedTest
@EnumSource(ChronoUnit.class)
void testWithExplicitArgumentConversion(
@ConvertWith(ToStringArgumentConverter.class) String argument) {

    assertNotNull(ChronoUnit.valueOf(argument));
}
```
```java
public class ToStringArgumentConverter extends SimpleArgumentConverter {

    @Override
    protected Object convert(Object source, Class<?> targetType) {
        assertEquals(String.class, targetType, "Can only convert to String");
        if (source instanceof Enum<?>) {
            return ((Enum<?>) source).name();
        }
        return String.valueOf(source);
    }
}
```
If the converter is only meant to convert one type to another, you can extend TypedArgumentConverter to avoid boilerplate type checks.
```java
public class ToLengthArgumentConverter extends TypedArgumentConverter<String, Integer> {

    protected ToLengthArgumentConverter() {
        super(String.class, Integer.class);
    }

    @Override
    protected Integer convert(String source) {
        return (source != null ? source.length() : 0);
    }

}
```
Explicit argument converters are meant to be implemented by test and extension authors.
Thus, junit-jupiter-params only provides a single explicit argument converter that may also serve as a reference implementation: JavaTimeArgumentConverter.
It is used via the composed annotation JavaTimeConversionPattern.

```java
@ParameterizedTest
@ValueSource(strings = { "01.01.2017", "31.12.2017" })
void testWithExplicitJavaTimeConverter(
@JavaTimeConversionPattern("dd.MM.yyyy") LocalDate argument) {

    assertEquals(2017, argument.getYear());
}
```
If you wish to implement a custom ArgumentConverter that also consumes an annotation (like JavaTimeArgumentConverter), you have the possibility to extend the AnnotationBasedArgumentConverter class.

### 2.16.5. Argument Aggregation
By default, each argument provided to a @ParameterizedTest method corresponds to a single method parameter. Consequently, argument sources which are expected to supply a large number of arguments can lead to large method signatures.

In such cases, an ArgumentsAccessor can be used instead of multiple parameters. Using this API, you can access the provided arguments through a single argument passed to your test method. In addition, type conversion is supported as discussed in Implicit Conversion.

Besides, you can retrieve the current test invocation index with ArgumentsAccessor.getInvocationIndex().
```java
@ParameterizedTest
@CsvSource({
"Jane, Doe, F, 1990-05-20",
"John, Doe, M, 1990-10-22"
})
void testWithArgumentsAccessor(ArgumentsAccessor arguments) {
    Person person = new Person(arguments.getString(0),
                              arguments.getString(1),
                              arguments.get(2, Gender.class),
                              arguments.get(3, LocalDate.class));

    if (person.getFirstName().equals("Jane")) {
        assertEquals(Gender.F, person.getGender());
    }
    else {
        assertEquals(Gender.M, person.getGender());
    }
    assertEquals("Doe", person.getLastName());
    assertEquals(1990, person.getDateOfBirth().getYear());
}
```
An instance of ArgumentsAccessor is automatically injected into any parameter of type ArgumentsAccessor.

#### Custom Aggregators
Apart from direct access to a @ParameterizedTest method’s arguments using an ArgumentsAccessor, JUnit Jupiter also supports the usage of custom, reusable aggregators.

To use a custom aggregator, implement the ArgumentsAggregator interface and register it via the @AggregateWith annotation on a compatible parameter in the @ParameterizedTest method. The result of the aggregation will then be provided as an argument for the corresponding parameter when the parameterized test is invoked. Note that an implementation of ArgumentsAggregator must be declared as either a top-level class or as a static nested class.
```java
@ParameterizedTest
@CsvSource({
    "Jane, Doe, F, 1990-05-20",
    "John, Doe, M, 1990-10-22"
})
void testWithArgumentsAggregator(@AggregateWith(PersonAggregator.class) Person person) {
    // perform assertions against person
}
```
```java
public class PersonAggregator implements ArgumentsAggregator {
    @Override
    public Person aggregateArguments(ArgumentsAccessor arguments, ParameterContext context) {
        return new Person(arguments.getString(0),
                        arguments.getString(1),
                        arguments.get(2, Gender.class),
                        arguments.get(3, LocalDate.class));
    }
}
```
If you find yourself repeatedly declaring @AggregateWith(MyTypeAggregator.class) for multiple parameterized test methods across your codebase, you may wish to create a custom composed annotation such as @CsvToMyType that is meta-annotated with @AggregateWith(MyTypeAggregator.class). The following example demonstrates this in action with a custom @CsvToPerson annotation.
```java
@ParameterizedTest
@CsvSource({
    "Jane, Doe, F, 1990-05-20",
    "John, Doe, M, 1990-10-22"
})
void testWithCustomAggregatorAnnotation(@CsvToPerson Person person) {
    // perform assertions against person
}
```
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PARAMETER)
@AggregateWith(PersonAggregator.class)
public @interface CsvToPerson {
}
```

### 2.16.6. Customizing Display Names
By default, the display name of a parameterized test invocation contains the invocation index and the String representation of all arguments for that specific invocation. Each of them is preceded by the parameter name (unless the argument is only available via an ArgumentsAccessor or ArgumentAggregator), if present in the bytecode (for Java, test code must be compiled with the -parameters compiler flag).

However, you can customize invocation display names via the name attribute of the @ParameterizedTest annotation like in the following example

```java
@DisplayName("Display name of container")
@ParameterizedTest(name = "{index} ==> the rank of ''{0}'' is {1}")
@CsvSource({ "apple, 1", "banana, 2", "'lemon, lime', 3" })
void testWithCustomDisplayNames(String fruit, int rank) {
}
```
When executing the above method using the ConsoleLauncher you will see output similar to the following.

```text
Display name of container ✔
├─ 1 ==> the rank of 'apple' is 1 ✔
├─ 2 ==> the rank of 'banana' is 2 ✔
└─ 3 ==> the rank of 'lemon, lime' is 3 ✔
```

Please note that name is a MessageFormat pattern. Thus, a single quote (') needs to be represented as a doubled single quote ('') in order to be displayed.

The following placeholders are supported within custom display names.


|Placeholder|Description|
|---|---|
|{displayName}|the display name of the method|
|{index}|the current invocation index (1-based)|
|{arguments}|the complete, comma-separated arguments list|
|{argumentsWithNames}|the complete, comma-separated arguments list with parameter names|
|{0}, {1}, …|an individual argument|

> When including arguments in display names, their string representations are truncated if they exceed the configured maximum length. The limit is configurable via the junit.jupiter.params.displayname.argument.maxlength configuration parameter and defaults to 512 characters.

When using @MethodSource or @ArgumentsSource, you can provide custom names for arguments using the Named API. A custom name will be used if the argument is included in the invocation display name, like in the example below.

```java
@DisplayName("A parameterized test with named arguments")
@ParameterizedTest(name = "{index}: {0}")
@MethodSource("namedArguments")
void testWithNamedArguments(File file) {
}

static Stream<Arguments> namedArguments() {
    return Stream.of(
        arguments(named("An important file", new File("path1"))),
        arguments(named("Another file", new File("path2")))
    );
}
```
```text
A parameterized test with named arguments ✔
├─ 1: An important file ✔
└─ 2: Another file ✔
```

If you’d like to set a default name pattern for all parameterized tests in your project, you can declare the junit.jupiter.params.displayname.default configuration parameter in the junit-platform.properties file as demonstrated in the following example (see Configuration Parameters for other options).
```properties
junit.jupiter.params.displayname.default = {index}
```

The display name for a parameterized test is determined according to the following precedence rules:

1. name attribute in @ParameterizedTest, if present
2. value of the junit.jupiter.params.displayname.default configuration parameter, if present
3. DEFAULT_DISPLAY_NAME constant defined in @ParameterizedTest


### 2.16.7. Lifecycle and Interoperability
Each invocation of a parameterized test has the same lifecycle as a regular @Test method. For example, @BeforeEach methods will be executed before each invocation. Similar to Dynamic Tests, invocations will appear one by one in the test tree of an IDE. You may at will mix regular @Test methods and @ParameterizedTest methods within the same test class.

You may use ParameterResolver extensions with @ParameterizedTest methods. However, method parameters that are resolved by argument sources need to come first in the argument list. Since a test class may contain regular tests as well as parameterized tests with different parameter lists, values from argument sources are not resolved for lifecycle methods (e.g. @BeforeEach) and test class constructors.

```java
@BeforeEach
void beforeEach(TestInfo testInfo) {
    // ...
}

@ParameterizedTest
@ValueSource(strings = "apple")
void testWithRegularParameterResolver(String argument, TestReporter testReporter) {
    testReporter.publishEntry("argument", argument);
}

@AfterEach
void afterEach(TestInfo testInfo) {
    // ...
}
```