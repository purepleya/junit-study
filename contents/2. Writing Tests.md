## 2.2 Definitions
### Lifecycle Method
@BeforeAll, @AfterAll, @BeforeEach, @AfterEach

### Test Class
Test class 는 abstract 여서는 안되며, 단 하나의 생성자(constructor)를 가져야 한다.
1. 최상위 class
2. static member class 
3. @Nested 로 정의되고 테스트 메소드를 하나이상 가지고 있는 class


## 2.3 Test Classes and Methods
test 함수와 lifecycle 함수는 현재 class 내부에 선언되거나, 부모 클래스나 interface 로 부터 상속 받는다.
덧 붙여, 테스트 함수와 라이프 사이클 함수는 추상 함수로 선언 될 수 없으면 return value 를 가질 수 없다. 

---
Class 와 method의 가시성
test class, test 함수, lifecycle 함수는 public 일 필요는 없으나 private로 선언되서는 안된다.<br/>
일반적으로, 다른 package에서 test class나 test 함수, lifecycle 함수 를 사용하는 경우를 제외하고 public 수정자를 생략하는것을 추천한다.
---
일반적인 test 함수와 lifecycle 함수의 사용 방법은 아래와 같다.
```java
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {
    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @Test
    void abortedTest() {
        assumeTrue("abc".contains("Z"));
        fail("test should have been aborted");
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }
}
```


## 2.4 Display Names
test class 와 test 함수는 @DisplayName 어노테이션을 통해 표시되는 테스트 명(display name)을 변경 할 수 있다. 표시 할 수 있는 테스트 명은 공백, 특수문자, 이모지 까지 가능하고, 변경한 테스트 명은 테스트 보고서나, 테스트 실행기, IDE 에서 표시 된다.

```java
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@DisplayName("A special test case")
class jh.study.junit.DisplayNameDemo {

    @Test
    @DisplayName("Custom test name containing spaces")
    void testWithDisplayNameContainingSpaces() {
    }

    @Test
    @DisplayName("╯°□°）╯")
    void testWithDisplayNameContainingSpecialCharacters() {
    }

    @Test
    @DisplayName("😱")
    void testWithDisplayNameContainingEmoji() {
    }

}
```

### 2.4.1. Display Name Generators
JUnit Jupiter는 @DisplayNameGeneration 어노테이션을 이용하는 custom display name 생성기를 지원한다.  
@DisplayName의 값이 @DisplayNameGeneration를 통해 생성된 값 보다 항상 우선한다.

DisplayNameGenerator를 구현함 으로서 생성기를 만 들 수 있다.  
아래는 Jupiter에서 기본을 제공하는 생성기 들이다.

|DisplayNameGenerator| Behavior                                                 |
|---|----------------------------------------------------------|
|Standard| Junit Jupiter 5.0이 출시 된 이후 사용되어오고 있는 기본 display name 생성기 |
|Simple| 파라미터가 없는 함수의 괄호를 삭제 하는 생성기                               |
|ReplaceUnderscores| 밑줄(underscore)을 공백(space)로 변환하는 생성기                      |
|IndicativeSentences| test와 이를 포함하는 class 명을 합쳐서 완성된 문장을 생성하는 생성기              |

@IndicativeSentencesGeneration 어노테이션을 이용하면, IndicativeSentences 기능에 separator(기본은 ", ")와 기본 display name 생성기를 별도로 정의 할 수 있다.
```java
class DisplayNameGeneratorDemo {

    @Nested
    @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_not_supported {

        @Test
        void if_it_is_zero() {}
//        if it is zero

        @DisplayName("A negative value for year is not supported by the leap year computation.")
        @ParameterizedTest(name = "For example, year {0} is not supported.")
        @ValueSource(ints = { -1, -4 })
        void if_it_is_negative(int year) {}
//        A negative value for year is not supported by the leap year computation.
//            For example, year -1 is not supported.
//            For example, year -4 is not supported.
    }

    @Nested
    @IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
    class A_year_is_a_leap_year {

        @Test
        void if_it_is_divisible_by_4_but_not_by_100() {
        }
//        A year is a leap year -> if it is divisible by 4 but not by 100

        @ParameterizedTest(name = "Year {0} is a leap year.")
        @ValueSource(ints = { 2016, 2020, 2048 })
        void if_it_is_one_of_the_following_years(int year) {
        }
//        A year is a leap year -> if it is one of the following years
//            Year 2016 is a leap year
//            Year 2020 is a leap year
//            Year 2048 is a leap year        
    }

}
```

### 2.4.2. Setting the Default Display Name Generator
junit 속성 파일 (src/test/resources/junit-platform.properties) 에 "junit.jupiter.displayname.generator.default"값을 이용하여 기본 display name 생성기를 설정 할 수 있다.  
@DisplayNameGeneration 어노테이션과 마찬가지로 설정 값 보다 @DisplayName 어노테이션의 값이 더 우선하며, 사용자가 DisplayNameGenerator를 구현하여 생성한 사용자 정의 display name 생성기 클래스도 적용 가능하다.  
```properties
junit.jupiter.displayname.generator.default = org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
```

## 2.5. Assertions
JUnit Jupiter 에서는 Junit 4에서 사용하던 assertion 함수에 Java 8 lambda 사용에 적합한 함수들이 추가 되었다. 
Junit Jupiter의 모든 assertion은 org.junit.jupiter.api.Assertions 클래스에 static 함수로 정의 되어 있다.

```java
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.CountDownLatch;

import example.domain.Person;
import example.util.Calculator;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

class AssertionsDemo {

    private final Calculator calculator = new Calculator();

    private final Person person = new Person("Jane", "Doe");

    @Test
    void standardAssertions() {
        assertEquals(2, calculator.add(1, 1));        
//        마지막 파라미터로 실패 메시지를 전달 할 수 있다.
        assertEquals(4, calculator.multiply(2, 2), "The optional failure message is now the last parameter");
//        supplier를 이용하여 실패 메시지를 지연 할 수 있다.
        assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- " + "to avoid constructing complex messages unnecessarily.");
    }

    @Test
    void groupedAssertions() {
        // In a grouped assertion all assertions are executed, and all
        // failures will be reported together.
        assertAll("person",
            () -> assertEquals("Jane", person.getFirstName()),
            () -> assertEquals("Doe", person.getLastName())
        );
    }

    @Test
    void dependentAssertions() {
        // Within a code block, if an assertion fails the
        // subsequent code in the same block will be skipped.
        assertAll("properties",
            () -> {
                String firstName = person.getFirstName();
                assertNotNull(firstName);

                // Executed only if the previous assertion is valid.
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("e"))
                );
            },
            () -> {
                // Grouped assertion, so processed independently
                // of results of first name assertions.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                // Executed only if the previous assertion is valid.
                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }

    @Test
    void exceptionTesting() {
        Exception exception = assertThrows(ArithmeticException.class, () ->
            calculator.divide(1, 0));
        assertEquals("/ by zero", exception.getMessage());
    }

    @Test
    void timeoutNotExceeded() {
        // The following assertion succeeds.
        assertTimeout(ofMinutes(2), () -> {
            // Perform task that takes less than 2 minutes.
        });
    }

    @Test
    void timeoutNotExceededWithResult() {
        // The following assertion succeeds, and returns the supplied object.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
            return "a result";
        });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
        // The following assertion invokes a method reference and returns an object.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("Hello, World!", actualGreeting);
    }

    @Test
    void timeoutExceeded() {
        // The following assertion fails with an error message similar to:
        // execution exceeded timeout of 10 ms by 91 ms
        assertTimeout(ofMillis(10), () -> {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100);
        });
    }

    @Test
    void timeoutExceededWithPreemptiveTermination() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(ofMillis(10), () -> {
            // Simulate task that takes more than 10 ms.
            new CountDownLatch(1).await();
        });
    }

    private static String greeting() {
        return "Hello, World!";
    }

}
```

---
assertTimeoutPreemptively() 함수를 이용한 선제적 타임아웃  
Assertions 클래스에 있는 다양한 assertTimeoutPreemptively()는 Executable 타입이나 Supplier 타입을 호출하는 코드와 분리된 다른 스레드에서 실행한다. Executable이나 Supplier의 코드가 java.lang.ThreadLocal storage를 이용하는 경우 부작용을 일으킬 수 있다.  

Spring Framework 에서 지원하는 트랜잭션 테스트가 대표적인 예 이다.
특별히 스프링 테스트는  테스트 함수가 실행 되기 전에 TreadLocal을 이용해 트랜잭션 상태를 현재 스레드에 바인딩 한다.
결과적으로, assertTimeoutPreemptively()함수에 제공된 Excutable이나 Sullpier가 트랜잭션에 포함되는 스프링 관리 콤포넌트를 실행한다면, 콤포넌트가 수행하는 어떤 행동들도 test에서 관리되는 트랜잭션과 함께 롤백되지 않는다.
이와 반대로, test 관리 트랜잭션이 롤백된다 하더라도, 해당 행동들은 db와 같은 persistent sotre에 커밋 된다.     

ThreadLocal storage를 이용하는 다른 프레임웍들도 비슷한 부작용을 일으킬 수 있다. 

---

### 2.5.1. Kotlin Assertion Support
JUnit Jupiter also comes with a few assertion methods that lend themselves well to being used in Kotlin. All JUnit Jupiter Kotlin assertions are top-level functions in the org.junit.jupiter.api package.
```kotlin
import example.domain.Person
import example.util.Calculator
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertAll
import org.junit.jupiter.api.assertDoesNotThrow
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.assertTimeout
import org.junit.jupiter.api.assertTimeoutPreemptively
import java.time.Duration

class KotlinAssertionsDemo {

    private val person = Person("Jane", "Doe")
    private val people = setOf(person, Person("John", "Doe"))

    @Test
    fun `exception absence testing`() {
        val calculator = Calculator()
        val result = assertDoesNotThrow("Should not throw an exception") {
            calculator.divide(0, 1)
        }
        assertEquals(0, result)
    }

    @Test
    fun `expected exception testing`() {
        val calculator = Calculator()
        val exception = assertThrows<ArithmeticException> ("Should throw an exception") {
            calculator.divide(1, 0)
        }
        assertEquals("/ by zero", exception.message)
    }

    @Test
    fun `grouped assertions`() {
        assertAll(
            "Person properties",
            { assertEquals("Jane", person.firstName) },
            { assertEquals("Doe", person.lastName) }
        )
    }

    @Test
    fun `grouped assertions from a stream`() {
        assertAll(
            "People with first name starting with J",
            people
                .stream()
                .map {
                    // This mapping returns Stream<() -> Unit>
                    { assertTrue(it.firstName.startsWith("J")) }
                }
        )
    }

    @Test
    fun `grouped assertions from a collection`() {
        assertAll(
            "People with last name of Doe",
            people.map { { assertEquals("Doe", it.lastName) } }
        )
    }

    @Test
    fun `timeout not exceeded testing`() {
        val fibonacciCalculator = FibonacciCalculator()
        val result = assertTimeout(Duration.ofMillis(1000)) {
            fibonacciCalculator.fib(14)
        }
        assertEquals(377, result)
    }

    @Test
    fun `timeout exceeded with preemptive termination`() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(Duration.ofMillis(10)) {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100)
        }
    }
}
```

### 2.5.2. Third-party Assertion Libraries
Even though the assertion facilities provided by JUnit Jupiter are sufficient for many testing scenarios, there are times when more power and additional functionality such as matchers are desired or required. In such cases, the JUnit team recommends the use of third-party assertion libraries such as AssertJ, Hamcrest, Truth, etc. Developers are therefore free to use the assertion library of their choice.

For example, the combination of matchers and a fluent API can be used to make assertions more descriptive and readable. However, JUnit Jupiter’s org.junit.jupiter.api.Assertions class does not provide an assertThat() method like the one found in JUnit 4’s org.junit.Assert class which accepts a Hamcrest Matcher. Instead, developers are encouraged to use the built-in support for matchers provided by third-party assertion libraries.

The following example demonstrates how to use the assertThat() support from Hamcrest in a JUnit Jupiter test. As long as the Hamcrest library has been added to the classpath, you can statically import methods such as assertThat(), is(), and equalTo() and then use them in tests like in the assertWithHamcrestMatcher() method below.

```java
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class HamcrestAssertionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void assertWithHamcrestMatcher() {
        assertThat(calculator.subtract(4, 1), is(equalTo(3)));
    }

}
```
Naturally, legacy tests based on the JUnit 4 programming model can continue using org.junit.Assert#assertThat.

