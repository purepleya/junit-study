## 2.2 Definitions
### Lifecycle Method
@BeforeAll, @AfterAll, @BeforeEach, @AfterEach

### Test Class
Test class ëŠ” abstract ì—¬ì„œëŠ” ì•ˆë˜ë©°, ë‹¨ í•˜ë‚˜ì˜ ìƒì„±ì(constructor)ë¥¼ ê°€ì ¸ì•¼ í•œë‹¤.
1. ìµœìƒìœ„ class
2. static member class 
3. @Nested ë¡œ ì •ì˜ë˜ê³  í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ í•˜ë‚˜ì´ìƒ ê°€ì§€ê³  ìˆëŠ” class


## 2.3 Test Classes and Methods
test í•¨ìˆ˜ì™€ lifecycle í•¨ìˆ˜ëŠ” í˜„ì¬ class ë‚´ë¶€ì— ì„ ì–¸ë˜ê±°ë‚˜, ë¶€ëª¨ í´ë˜ìŠ¤ë‚˜ interface ë¡œ ë¶€í„° ìƒì† ë°›ëŠ”ë‹¤.
ë§ ë¶™ì—¬, í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ì™€ ë¼ì´í”„ ì‚¬ì´í´ í•¨ìˆ˜ëŠ” ì¶”ìƒ í•¨ìˆ˜ë¡œ ì„ ì–¸ ë  ìˆ˜ ì—†ìœ¼ë©´ return value ë¥¼ ê°€ì§ˆ ìˆ˜ ì—†ë‹¤. 

---
_Class ì™€ methodì˜ ê°€ì‹œì„±
test class, test í•¨ìˆ˜, lifecycle í•¨ìˆ˜ëŠ” public ì¼ í•„ìš”ëŠ” ì—†ìœ¼ë‚˜ privateë¡œ ì„ ì–¸ë˜ì„œëŠ” ì•ˆëœë‹¤.<br/>
ì¼ë°˜ì ìœ¼ë¡œ, ë‹¤ë¥¸ packageì—ì„œ test classë‚˜ test í•¨ìˆ˜, lifecycle í•¨ìˆ˜ ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ë¥¼ ì œì™¸í•˜ê³  public ìˆ˜ì •ìë¥¼ ìƒëµí•˜ëŠ”ê²ƒì„ ì¶”ì²œí•œë‹¤._
---
ì¼ë°˜ì ì¸ test í•¨ìˆ˜ì™€ lifecycle í•¨ìˆ˜ì˜ ì‚¬ìš© ë°©ë²•ì€ ì•„ë˜ì™€ ê°™ë‹¤.
```java
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {
    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @Test
    void abortedTest() {
        assumeTrue("abc".contains("Z"));
        fail("test should have been aborted");
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }
}
```


## 2.4 Display Names
test class ì™€ test í•¨ìˆ˜ëŠ” @DisplayName ì–´ë…¸í…Œì´ì…˜ì„ í†µí•´ í‘œì‹œë˜ëŠ” í…ŒìŠ¤íŠ¸ ëª…(display name)ì„ ë³€ê²½ í•  ìˆ˜ ìˆë‹¤. í‘œì‹œ í•  ìˆ˜ ìˆëŠ” í…ŒìŠ¤íŠ¸ ëª…ì€ ê³µë°±, íŠ¹ìˆ˜ë¬¸ì, ì´ëª¨ì§€ ê¹Œì§€ ê°€ëŠ¥í•˜ê³ , ë³€ê²½í•œ í…ŒìŠ¤íŠ¸ ëª…ì€ í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œë‚˜, í…ŒìŠ¤íŠ¸ ì‹¤í–‰ê¸°, IDE ì—ì„œ í‘œì‹œ ëœë‹¤.

```java
@DisplayName("A special test case")
class DisplayNameDemo {

    @Test
    @DisplayName("Custom test name containing spaces")
    void testWithDisplayNameContainingSpaces() {
    }

    @Test
    @DisplayName("â•¯Â°â–¡Â°ï¼‰â•¯")
    void testWithDisplayNameContainingSpecialCharacters() {
    }

    @Test
    @DisplayName("ğŸ˜±")
    void testWithDisplayNameContainingEmoji() {
    }

}
```

### 2.4.1. Display Name Generators
JUnit JupiterëŠ” @DisplayNameGeneration ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•˜ëŠ” custom display name ìƒì„±ê¸°ë¥¼ ì§€ì›í•œë‹¤.  
@DisplayNameì˜ ê°’ì´ @DisplayNameGenerationë¥¼ í†µí•´ ìƒì„±ëœ ê°’ ë³´ë‹¤ í•­ìƒ ìš°ì„ í•œë‹¤.

DisplayNameGeneratorë¥¼ êµ¬í˜„í•¨ ìœ¼ë¡œì„œ ìƒì„±ê¸°ë¥¼ ë§Œ ë“¤ ìˆ˜ ìˆë‹¤.  
ì•„ë˜ëŠ” Jupiterì—ì„œ ê¸°ë³¸ì„ ì œê³µí•˜ëŠ” ìƒì„±ê¸° ë“¤ì´ë‹¤.

|DisplayNameGenerator| Behavior                                                 |
|---|----------------------------------------------------------|
|Standard| Junit Jupiter 5.0ì´ ì¶œì‹œ ëœ ì´í›„ ì‚¬ìš©ë˜ì–´ì˜¤ê³  ìˆëŠ” ê¸°ë³¸ display name ìƒì„±ê¸° |
|Simple| íŒŒë¼ë¯¸í„°ê°€ ì—†ëŠ” í•¨ìˆ˜ì˜ ê´„í˜¸ë¥¼ ì‚­ì œ í•˜ëŠ” ìƒì„±ê¸°                               |
|ReplaceUnderscores| ë°‘ì¤„(underscore)ì„ ê³µë°±(space)ë¡œ ë³€í™˜í•˜ëŠ” ìƒì„±ê¸°                      |
|IndicativeSentences| testì™€ ì´ë¥¼ í¬í•¨í•˜ëŠ” class ëª…ì„ í•©ì³ì„œ ì™„ì„±ëœ ë¬¸ì¥ì„ ìƒì„±í•˜ëŠ” ìƒì„±ê¸°              |

@IndicativeSentencesGeneration ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•˜ë©´, IndicativeSentences ê¸°ëŠ¥ì— separator(ê¸°ë³¸ì€ ", ")ì™€ ê¸°ë³¸ display name ìƒì„±ê¸°ë¥¼ ë³„ë„ë¡œ ì •ì˜ í•  ìˆ˜ ìˆë‹¤.
```java
class DisplayNameGeneratorDemo {

    @Nested
    @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_not_supported {

        @Test
        void if_it_is_zero() {}
//        if it is zero

        @DisplayName("A negative value for year is not supported by the leap year computation.")
        @ParameterizedTest(name = "For example, year {0} is not supported.")
        @ValueSource(ints = { -1, -4 })
        void if_it_is_negative(int year) {}
//        A negative value for year is not supported by the leap year computation.
//            For example, year -1 is not supported.
//            For example, year -4 is not supported.
    }

    @Nested
    @IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
    class A_year_is_a_leap_year {

        @Test
        void if_it_is_divisible_by_4_but_not_by_100() {
        }
//        A year is a leap year -> if it is divisible by 4 but not by 100

        @ParameterizedTest(name = "Year {0} is a leap year.")
        @ValueSource(ints = { 2016, 2020, 2048 })
        void if_it_is_one_of_the_following_years(int year) {
        }
//        A year is a leap year -> if it is one of the following years
//            Year 2016 is a leap year
//            Year 2020 is a leap year
//            Year 2048 is a leap year        
    }

}
```

### 2.4.2. Setting the Default Display Name Generator
junit ì†ì„± íŒŒì¼ (src/test/resources/junit-platform.properties) ì— "junit.jupiter.displayname.generator.default"ê°’ì„ ì´ìš©í•˜ì—¬ ê¸°ë³¸ display name ìƒì„±ê¸°ë¥¼ ì„¤ì • í•  ìˆ˜ ìˆë‹¤.  
@DisplayNameGeneration ì–´ë…¸í…Œì´ì…˜ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ì„¤ì • ê°’ ë³´ë‹¤ @DisplayName ì–´ë…¸í…Œì´ì…˜ì˜ ê°’ì´ ë” ìš°ì„ í•˜ë©°, ì‚¬ìš©ìê°€ DisplayNameGeneratorë¥¼ êµ¬í˜„í•˜ì—¬ ìƒì„±í•œ ì‚¬ìš©ì ì •ì˜ display name ìƒì„±ê¸° í´ë˜ìŠ¤ë„ ì ìš© ê°€ëŠ¥í•˜ë‹¤.  
```properties
junit.jupiter.displayname.generator.default = org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
```

## 2.5. Assertions
JUnit Jupiter ì—ì„œëŠ” Junit 4ì—ì„œ ì‚¬ìš©í•˜ë˜ assertion í•¨ìˆ˜ì— Java 8 lambda ì‚¬ìš©ì— ì í•©í•œ í•¨ìˆ˜ë“¤ì´ ì¶”ê°€ ë˜ì—ˆë‹¤. 
Junit Jupiterì˜ ëª¨ë“  assertionì€ org.junit.jupiter.api.Assertions í´ë˜ìŠ¤ì— static í•¨ìˆ˜ë¡œ ì •ì˜ ë˜ì–´ ìˆë‹¤.

```java
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.CountDownLatch;

import example.domain.Person;
import example.util.Calculator;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

class AssertionsDemo {

    private final Calculator calculator = new Calculator();

    private final Person person = new Person("Jane", "Doe");

    @Test
    void standardAssertions() {
        assertEquals(2, calculator.add(1, 1));        
//        ë§ˆì§€ë§‰ íŒŒë¼ë¯¸í„°ë¡œ ì‹¤íŒ¨ ë©”ì‹œì§€ë¥¼ ì „ë‹¬ í•  ìˆ˜ ìˆë‹¤.
        assertEquals(4, calculator.multiply(2, 2), "The optional failure message is now the last parameter");
//        supplierë¥¼ ì´ìš©í•˜ì—¬ ì‹¤íŒ¨ ë©”ì‹œì§€ë¥¼ ì§€ì—° í•  ìˆ˜ ìˆë‹¤.
        assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- " + "to avoid constructing complex messages unnecessarily.");
    }

    @Test
    void groupedAssertions() {
//        assertAll ì„ ì´ìš©í•´ì„œ ë³µìˆ˜ê±´ì„ í•œë²ˆì— ê²€ì¦ í•  ìˆ˜ ìˆë‹¤.
        assertAll("person",
            () -> assertEquals("Jane", person.getFirstName()),
            () -> assertEquals("Doe", person.getLastName())
        );
    }

    @Test
    void dependentAssertions() {
        assertAll("properties",
            () -> {
//                ì½”ë“œë¸”ë¡ ì•ˆì— assertion ì½”ë“œë¥¼ ì‘ì„±í•œ ê²½ìš°, assertionì´ ì‹¤íŒ¨í•˜ë©´ ì´í›„ ì½”ë“œëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤. ëª¨ë“  assertion ì´ ì„±ê³µí•œ ì´í›„ ì½”ë“œê°€ ì‹¤í–‰ëœë‹¤.
                String firstName = person.getFirstName();
                assertNotNull(firstName);
                assertEquals("Jane", firstName);
                
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("e"))
                );
            },
            () -> {
//                assertAll ì˜ ê° ê°œë³„ assertionì€ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì—, assertionì´ ì‹¤íŒ¨í•˜ë”ë¼ë„ ì´í›„ assertionì€ ì‹¤í–‰ëœë‹¤.
//                ì•„ë˜ ì½”ë“œëŠ” ìœ„ì˜ firstName assertionì´ ì‹¤íŒ¨í•˜ë”ë¼ë„ ì‹¤í–‰ëœë‹¤.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }

    @Test
    void exceptionTesting() {
//        ë°œìƒì´ ì˜ˆìƒë˜ëŠ” Exception ì„ assertThrows ì˜ ì²«ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬í•˜ê³ , ë‘ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¡œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ëŠ” ì½”ë“œë¥¼ ëŒë‹¤ë¡œ ì „ë‹¬í•˜ì—¬
//        ì˜ˆìƒí•œ Exception ì´ ë°œìƒí•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.
        Exception exception = assertThrows(ArithmeticException.class, () ->
            calculator.divide(1, 0));
        assertEquals("/ by zero", exception.getMessage());
    }

    @Test
    void timeoutNotExceeded() {
//        ì½”ë“œì‹¤í–‰ ì‹œê°„ì´ 2ì´ˆë¥¼ ë„˜ê¸°ë©´ assertion ì‹¤íŒ¨í•œë‹¤.
        assertTimeout(Duration.ofSeconds(2), () -> {
            Thread.sleep(1000);
        });
    }
    
    @Test
    void timeoutNotExceededWithResult() {
//        ì½”ë“œê°€ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆì— ê²°ê³¼ê°’ì„ ë¦¬í„´í•˜ëŠ” ê²½ìš°, ë¦¬í„´ëœ ê²°ê³¼ê°’ì„ assertion í•  ìˆ˜ ìˆë‹¤.
//        Timeout ì´ ë°œìƒí•˜ë©´ assertion ì‹¤íŒ¨í•˜ê³  í…ŒìŠ¤íŠ¸ ì¢…ë£Œë˜ë©°, Timeout ì´ ë°œìƒí•˜ì§€ ì•Šìœ¼ë©´ ë¦¬í„´ëœ ê²°ê³¼ê°’ì„ assertion í•œë‹¤.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
            return "a result";
        });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
//        method ì°¸ì¡°ë¥¼ ì´ìš©í•˜ì—¬ assertion í•  ìˆ˜ ìˆë‹¤.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("Hello, World!", actualGreeting);
    }
    
    @Test
    void timeoutExceededWithPreemptiveTermination() {
//        timeoutExceededWithPreemptiveTermination í•¨ìˆ˜ë¥¼ ì´ìš©í•´ì„œ assertTimeout ê³¼ ê°™ì€ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰ í•  ìˆ˜ ìˆë‹¤.
//        timeoutExceededWithPreemptiveTerminationê°€ assertTimeout ê³¼ ë‹¤ë¥¸ ì ì€ ì•„ë˜ ì„¤ëª… ì°¸ê³ 
        assertTimeoutPreemptively(ofMillis(10), () -> {
            new CountDownLatch(1).await();
        });
    }

    private static String greeting() {
        return "Hello, World!";
    }

}
```

---
_assertTimeoutPreemptively() í•¨ìˆ˜ë¥¼ ì´ìš©í•œ ì„ ì œì  íƒ€ì„ì•„ì›ƒ  
Assertions í´ë˜ìŠ¤ì— ìˆëŠ” ë‹¤ì–‘í•œ assertTimeoutPreemptively()ëŠ” Executable íƒ€ì…ì´ë‚˜ Supplier íƒ€ì…ì„ í˜¸ì¶œí•˜ëŠ” ì½”ë“œì™€ ë¶„ë¦¬ëœ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰í•œë‹¤. Executableì´ë‚˜ Supplierì˜ ì½”ë“œê°€ java.lang.ThreadLocal storageë¥¼ ì´ìš©í•˜ëŠ” ê²½ìš° ë¶€ì‘ìš©ì„ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤.  
Spring Framework ì—ì„œ ì§€ì›í•˜ëŠ” íŠ¸ëœì­ì…˜ í…ŒìŠ¤íŠ¸ê°€ ëŒ€í‘œì ì¸ ì˜ˆ ì´ë‹¤.  
íŠ¹ë³„íˆ ìŠ¤í”„ë§ í…ŒìŠ¤íŠ¸ëŠ”  í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ê°€ ì‹¤í–‰ ë˜ê¸° ì „ì— TreadLocalì„ ì´ìš©í•´ íŠ¸ëœì­ì…˜ ìƒíƒœë¥¼ í˜„ì¬ ìŠ¤ë ˆë“œì— ë°”ì¸ë”© í•œë‹¤.  
ê²°ê³¼ì ìœ¼ë¡œ, assertTimeoutPreemptively()í•¨ìˆ˜ì— ì œê³µëœ Excutableì´ë‚˜ Sullpierê°€ íŠ¸ëœì­ì…˜ì— í¬í•¨ë˜ëŠ” ìŠ¤í”„ë§ ê´€ë¦¬ ì½¤í¬ë„ŒíŠ¸ë¥¼ ì‹¤í–‰í•œë‹¤ë©´, ì½¤í¬ë„ŒíŠ¸ê°€ ìˆ˜í–‰í•˜ëŠ” ì–´ë–¤ í–‰ë™ë“¤ë„ testì—ì„œ ê´€ë¦¬ë˜ëŠ” íŠ¸ëœì­ì…˜ê³¼ í•¨ê»˜ ë¡¤ë°±ë˜ì§€ ì•ŠëŠ”ë‹¤.
ì´ì™€ ë°˜ëŒ€ë¡œ, test ê´€ë¦¬ íŠ¸ëœì­ì…˜ì´ ë¡¤ë°±ëœë‹¤ í•˜ë”ë¼ë„, í•´ë‹¹ í–‰ë™ë“¤ì€ dbì™€ ê°™ì€ persistent sotreì— ì»¤ë°‹ ëœë‹¤.  
ThreadLocal storageë¥¼ ì´ìš©í•˜ëŠ” ë‹¤ë¥¸ í”„ë ˆì„ì›ë“¤ë„ ë¹„ìŠ·í•œ ë¶€ì‘ìš©ì„ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤._
---

### 2.5.1. Kotlin Assertion Support
JUnit Jupiter ëŠ” Kotlinì— ì í•©í•œ assertion í•¨ìˆ˜ë„ ì¼ë¶€ ì§€ì›í•˜ê³ , ì´ëŠ” JUnit Jupiterì˜ org.junit.jupiter.api íŒ¨í‚¤ì§€ì˜ ìµœ ìƒìœ„ í•¨ìˆ˜ë¡œ ë˜ì–´ ìˆë‹¤.  
Kotlin ê´€ë ¨ ë‚´ìš©ì€ ì¼ë‹¨ íŒ¨ìŠ¤~~~

```kotlin
import example.domain.Person
import example.util.Calculator
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertAll
import org.junit.jupiter.api.assertDoesNotThrow
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.assertTimeout
import org.junit.jupiter.api.assertTimeoutPreemptively
import java.time.Duration

class KotlinAssertionsDemo {

    private val person = Person("Jane", "Doe")
    private val people = setOf(person, Person("John", "Doe"))

    @Test
    fun `exception absence testing`() {
        val calculator = Calculator()
        val result = assertDoesNotThrow("Should not throw an exception") {
            calculator.divide(0, 1)
        }
        assertEquals(0, result)
    }

    @Test
    fun `expected exception testing`() {
        val calculator = Calculator()
        val exception = assertThrows<ArithmeticException> ("Should throw an exception") {
            calculator.divide(1, 0)
        }
        assertEquals("/ by zero", exception.message)
    }

    @Test
    fun `grouped assertions`() {
        assertAll(
            "Person properties",
            { assertEquals("Jane", person.firstName) },
            { assertEquals("Doe", person.lastName) }
        )
    }

    @Test
    fun `grouped assertions from a stream`() {
        assertAll(
            "People with first name starting with J",
            people
                .stream()
                .map {
                    // This mapping returns Stream<() -> Unit>
                    { assertTrue(it.firstName.startsWith("J")) }
                }
        )
    }

    @Test
    fun `grouped assertions from a collection`() {
        assertAll(
            "People with last name of Doe",
            people.map { { assertEquals("Doe", it.lastName) } }
        )
    }

    @Test
    fun `timeout not exceeded testing`() {
        val fibonacciCalculator = FibonacciCalculator()
        val result = assertTimeout(Duration.ofMillis(1000)) {
            fibonacciCalculator.fib(14)
        }
        assertEquals(377, result)
    }

    @Test
    fun `timeout exceeded with preemptive termination`() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(Duration.ofMillis(10)) {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100)
        }
    }
}
```

### 2.5.2. Third-party Assertion Libraries
JUnit Jupiterì— ì˜í•´ ì œê³µë˜ëŠ” assertion ê¸°ëŠ¥ë“¤ì´ ë§ì€ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ì— ì í•©í•˜ë‹¤ í•˜ë”ë¼ë„, ë•Œë•Œë¡œ matcherì™€ ê°™ì€ ì¶”ê°€ ê¸°ëŠ¥ë“¤ì´ í•„ìš”í•œ ê²½ìš°ê°€ ìˆë‹¤.
ê·¸ëŸ° ê²½ìš°, JUnit íŒ€ì€ AssertJ, Hamcrest, Truth ë“±ì˜ ì„œë“œíŒŒí‹° assertion ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•  ê²ƒì„ ê¶Œì¥í•œë‹¤.

ì˜ˆë¡œ, matcherì™€ fluent APIì˜ ì¡°í•©ì€ assertionì„ ë” ìì„¸í•˜ê³  ì½ê¸° ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë‚˜ Junit 4ì—ì„œ ì§€ì›í•˜ê³  Hamcrest Matcherì—ì„œ ì±„íƒëœ assertThat() í•¨ìˆ˜ëŠ” JUnit Jupiterì—ì„œëŠ” ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤.
ëŒ€ì‹ , ê°œë°œìë“¤ì€ ì„œë“œíŒŒí‹° assertion ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µí•˜ëŠ” matcherë¥¼ ì‚¬ìš©í•  ê²ƒì„ ê¶Œì¥í•œë‹¤. 

ì•„ë˜ ì˜ˆì œëŠ” JUnit Jupiter í…ŒìŠ¤íŠ¸ì—ì„œ Hamcrestì˜ assertThat() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤€ë‹¤. Hamcrest ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ classpathì— ì¶”ê°€ë˜ì–´ ìˆëŠ”í•œ, assertThat(), is(), equalTo()ì™€ ê°™ì€ í•¨ìˆ˜ë“¤ì„ static import í•  ìˆ˜ ìˆê³ , ì•„ë˜ì˜ assertWithHamcrestMatcher() í•¨ìˆ˜ì²˜ëŸ¼ í…ŒìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```java
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class HamcrestAssertionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void assertWithHamcrestMatcher() {
        assertThat(calculator.subtract(4, 1), is(equalTo(3)));
    }

}
```
ë¬¼ë¡ , JUnit 4 í”„ë¡œê·¸ë˜ë° ëª¨ë¸ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ë ˆê±°ì‹œ í…ŒìŠ¤íŠ¸ëŠ” org.junit.Assert#assertThatì„ ê³„ì† ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.


## 2.6. Assumptions
JUnit Jupiter ì—ëŠ” JUnit 4ì—ì„œ ì œê³µí•˜ëŠ” assumption ë©”ì†Œë“œì˜ í•˜ìœ„ ì§‘í•©ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©°, Java 8 ëŒë‹¤ í‘œí˜„ì‹ê³¼ ë©”ì†Œë“œ ì°¸ì¡°ë¥¼ ì‚¬ìš©í•˜ëŠ” ë° ì í•©í•œ ëª‡ ê°€ì§€ ë©”ì†Œë“œê°€ ì¶”ê°€ë˜ì—ˆë‹¤. 
ëª¨ë“  JUnit Jupiter assumption ë©”ì†Œë“œëŠ” org.junit.jupiter.api.Assumptions í´ë˜ìŠ¤ì— static ìœ¼ë¡œ ì •ì˜ ë˜ì–´ ìˆë‹¤.

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.junit.jupiter.api.Assumptions.assumingThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssumptionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void testOnlyOnCiServer() {
        assumeTrue("CI".equals(System.getenv("ENV")));
    }

    @Test
    void testOnlyOnDeveloperWorkstation() {
//        í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í•˜ë©´, í…ŒìŠ¤íŠ¸ëŠ” ì‹¤íŒ¨ë¡œ í‘œì‹œë˜ì§€ ì•Šê³ , ë¬´ì‹œëœë‹¤.
//        í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í•  ê²½ìš° "Assumption failed: Aborting test: not on developer workstation" ë©”ì‹œì§€ê°€ í‘œì‹œëœë‹¤.
        assumeTrue("DEV".equals(System.getenv("ENV")),
                () -> "Aborting test: not on developer workstation");
    }

    @Test
    void testInAllEnvironments() {
//        ì²«ë²ˆì§¸ íŒŒë¼ë¯¸í„°ê°€ true ì¼ ê²½ìš°, ë‘ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬ëœ ëŒë‹¤ í‘œí˜„ì‹ì´ ì‹¤í–‰ëœë‹¤.
//        ì²œë²ˆì§¸ íŒŒë¼ë¯¸í„°ê°€ false ì¼ ê²½ìš°, ë‘ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬ëœ ëŒë‹¤ í‘œí˜„ì‹ì€ ë¬´ì‹œ ëœë‹¤.
        assumingThat("CI".equals(System.getenv("ENV")),
                () -> {
                    assertEquals(2, calculator.divide(4, 2));
                });

        // System.getenv("ENV") ê°€ CI ì´ë˜ ì•„ë‹ˆë˜, (ì¤‘ê°„ì— assertion ì´ ì‹¤íŒ¨í•˜ì§€ ì•ŠëŠ” ì´ìƒ) ë¬´ì¡°ê±´ ì‹¤í–‰ ëœë‹¤.
        assertEquals(42, calculator.multiply(6, 7));
    }

}
```

---
_JUnit Jupiter 5.4 ì´í›„ë¡œ, JUnit 4ì˜ org.junit.Assume í´ë˜ìŠ¤ì˜ ë©”ì†Œë“œë¥¼ assumptionìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. íŠ¹íˆ, JUnit JupiterëŠ” JUnit 4ì˜ AssumptionViolatedExceptionì„ ì§€ì›í•˜ì—¬ í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨ë¡œ í‘œì‹œë˜ëŠ” ëŒ€ì‹  í…ŒìŠ¤íŠ¸ê°€ ì¤‘ë‹¨ë˜ì–´ì•¼ í•¨ì„ ë‚˜íƒ€ë‚¸ë‹¤._

---


## 2.7. Disabling Tests
í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë‚˜ ê°œë³„ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ ë¹„ í™œì„±í™” ì‹œí‚¤ëŠ” ë°©ë²•
1. @Disabled ì–´ë…¸í…Œì´ì…˜
2. Conditional Test Execution ì—ì„œ ì„¤ëª…í•œ ì–´ë…¸í…Œì´ì…˜ ì‚¬ìš©
3. ì‚¬ìš©ì ì •ì˜ ExecutionConditionì„ ì‚¬ìš©

@Disabled ì˜ˆì œ
```java
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

public class DisabledDemo {
    @Disabled("Disabled until bug #42 has been resolved")
    @Test
    void testWillBeSkipped() {
    }

    @Test
    void testWillBeExecuted() {
    }

    @Disabled
    @Nested
    class DisabledTestClass {
        @Test
        void testWillBeSkipped() {
        }
    }

    @Nested
    class EnsabledTestClass {
        @Test
        void testWillBeExecuted() {
        }
    }

}
```
---
_@Disabledë¥¼ ì‚¬ìš©í• ë•Œ ì´ìœ ë¥¼ ì‘ì„± í•˜ì§€ ì•Šì•„ë„ ëœë‹¤. í•˜ì§€ë§Œ JUnit íŒ€ì€ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë‚˜ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ê°€ ì™œ ë¹„í™œì„±í™” ë˜ì—ˆëŠ”ì§€ì— ëŒ€í•œ ê°„ë‹¨í•œ ì„¤ëª…ì„ ì‘ì„±í•  ê²ƒì„ ê¶Œì¥í•œë‹¤._ 

---


## 2.8. Conditional Test Execution
The ExecutionCondition extension API in JUnit Jupiter allows developers to either enable or disable a container or test based on certain conditions programmatically. The simplest example of such a condition is the built-in DisabledCondition which supports the @Disabled annotation (see Disabling Tests). In addition to @Disabled, JUnit Jupiter also supports several other annotation-based conditions in the org.junit.jupiter.api.condition package that allow developers to enable or disable containers and tests declaratively. When multiple ExecutionCondition extensions are registered, a container or test is disabled as soon as one of the conditions returns disabled. If you wish to provide details about why they might be disabled, every annotation associated with these built-in conditions has a disabledReason attribute available for that purpose.

See ExecutionCondition and the following sections for details.

---
_Composed Annotations
Note that any of the conditional annotations listed in the following sections may also be used as a meta-annotation in order to create a custom composed annotation. For example, the @TestOnMac annotation in the @EnabledOnOs demo shows how you can combine @Test and @EnabledOnOs in a single, reusable annotation._

---

---
_Unless otherwise stated, each of the conditional annotations listed in the following sections can only be declared once on a given test interface, test class, or test method. If a conditional annotation is directly present, indirectly present, or meta-present multiple times on a given element, only the first such annotation discovered by JUnit will be used; any additional declarations will be silently ignored. Note, however, that each conditional annotation may be used in conjunction with other conditional annotations in the org.junit.jupiter.api.condition package._

---

### 2.8.1. Operating System and Architecture Conditions
A container or test may be enabled or disabled on a particular operating system, architecture, or combination of both via the @EnabledOnOs and @DisabledOnOs annotations.

_Conditional execution based on operating system_
```java
@Test
@EnabledOnOs(MAC)
void onlyOnMacOs() {
    // ...
}

@TestOnMac
void testOnMac() {
    // ...
}

@Test
@EnabledOnOs({ LINUX, MAC })
void onLinuxOrMac() {
    // ...
}

@Test
@DisabledOnOs(WINDOWS)
void notOnWindows() {
    // ...
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Test
@EnabledOnOs(MAC)
@interface TestOnMac {
}
```
_Conditional execution based on architecture_
```java
@Test
@EnabledOnOs(architectures = "aarch64")
void onAarch64() {
    // ...
}

@Test
@DisabledOnOs(architectures = "x86_64")
void notOnX86_64() {
    // ...
}

@Test
@EnabledOnOs(value = MAC, architectures = "aarch64")
void onNewMacs() {
    // ...
}

@Test
@DisabledOnOs(value = MAC, architectures = "aarch64")
void notOnNewMacs() {
    // ...
}
```

### 2.8.2. Java Runtime Environment Conditions
A container or test may be enabled or disabled on particular versions of the Java Runtime Environment (JRE) via the @EnabledOnJre and @DisabledOnJre annotations or on a particular range of versions of the JRE via the @EnabledForJreRange and @DisabledForJreRange annotations. The range defaults to JRE.JAVA_8 as the lower border (min) and JRE.OTHER as the higher border (max), which allows usage of half open ranges.

```java
@Test
@EnabledOnJre(JAVA_8)
void onlyOnJava8() {
    // ...
}

@Test
@EnabledOnJre({ JAVA_9, JAVA_10 })
void onJava9Or10() {
    // ...
}

@Test
@EnabledForJreRange(min = JAVA_9, max = JAVA_11)
void fromJava9to11() {
    // ...
}

@Test
@EnabledForJreRange(min = JAVA_9)
void fromJava9toCurrentJavaFeatureNumber() {
    // ...
}

@Test
@EnabledForJreRange(max = JAVA_11)
void fromJava8To11() {
    // ...
}

@Test
@DisabledOnJre(JAVA_9)
void notOnJava9() {
    // ...
}

@Test
@DisabledForJreRange(min = JAVA_9, max = JAVA_11)
void notFromJava9to11() {
    // ...
}

@Test
@DisabledForJreRange(min = JAVA_9)
void notFromJava9toCurrentJavaFeatureNumber() {
    // ...
}

@Test
@DisabledForJreRange(max = JAVA_11)
void notFromJava8to11() {
    // ...
}
```

### 2.8.3. Native Image Conditions
A container or test may be enabled or disabled within a GraalVM native image via the @EnabledInNativeImage and @DisabledInNativeImage annotations. These annotations are typically used when running tests within a native image using the Gradle and Maven plug-ins from the GraalVM Native Build Tools project.

```java
@Test
@EnabledInNativeImage
void onlyWithinNativeImage() {
    // ...
}

@Test
@DisabledInNativeImage
void neverWithinNativeImage() {
    // ...
}
```

### 2.8.4. System Property Conditions
A container or test may be enabled or disabled based on the value of the named JVM system property via the @EnabledIfSystemProperty and @DisabledIfSystemProperty annotations. The value supplied via the matches attribute will be interpreted as a regular expression.

```java
@Test
@EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*")
void onlyOn64BitArchitectures() {
    // ...
}

@Test
@DisabledIfSystemProperty(named = "ci-server", matches = "true")
void notOnCiServer() {
    // ...
}
```
---
_As of JUnit Jupiter 5.6, @EnabledIfSystemProperty and @DisabledIfSystemProperty are repeatable annotations. Consequently, these annotations may be declared multiple times on a test interface, test class, or test method. Specifically, these annotations will be found if they are directly present, indirectly present, or meta-present on a given element._

---

### 2.8.5. Environment Variable Conditions
A container or test may be enabled or disabled based on the value of the named environment variable from the underlying operating system via the @EnabledIfEnvironmentVariable and @DisabledIfEnvironmentVariable annotations. The value supplied via the matches attribute will be interpreted as a regular expression.

```java
@Test
@EnabledIfEnvironmentVariable(named = "ENV", matches = "staging-server")
void onlyOnStagingServer() {
    // ...
}

@Test
@DisabledIfEnvironmentVariable(named = "ENV", matches = ".*development.*")
void notOnDeveloperWorkstation() {
    // ...
}
```
---
_
As of JUnit Jupiter 5.6, @EnabledIfEnvironmentVariable and @DisabledIfEnvironmentVariable are repeatable annotations. Consequently, these annotations may be declared multiple times on a test interface, test class, or test method. Specifically, these annotations will be found if they are directly present, indirectly present, or meta-present on a given element._

---

### 2.8.6. Custom Conditions
As an alternative to implementing an ExecutionCondition, a container or test may be enabled or disabled based on a condition method configured via the @EnabledIf and @DisabledIf annotations. A condition method must have a boolean return type and may accept either no arguments or a single ExtensionContext argument.

The following test class demonstrates how to configure a local method named customCondition via @EnabledIf and @DisabledIf.

```java
@Test
@EnabledIf("customCondition")
void enabled() {
    // ...
}

@Test
@DisabledIf("customCondition")
void disabled() {
    // ...
}

boolean customCondition() {
    return true;
}
```
Alternatively, the condition method can be located outside the test class. In this case, it must be referenced by its fully qualified name as demonstrated in the following example.

```java
package example;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIf;

class ExternalCustomConditionDemo {

    @Test
    @EnabledIf("example.ExternalCondition#customCondition")
    void enabled() {
        // ...
    }

}

class ExternalCondition {

    static boolean customCondition() {
        return true;
    }

}
```
---
_
There are several cases where a condition method would need to be static:_

_when @EnabledIf or @DisabledIf is used at class level_

_when @EnabledIf or @DisabledIf is used on a @ParameterizedTest or a @TestTemplate method_

_when the condition method is located in an external class_

_In any other case, you can use either static methods or instance methods as condition methods._

---
---
_For example, java.awt.GraphicsEnvironment provides a public static boolean isHeadless() method that can be used to determine if the current environment does not support a graphical display. Thus, if you have a test that depends on graphical support you can disable it when such support is unavailable as follows._
```java
@DisabledIf(value = "java.awt.GraphicsEnvironment#isHeadless",
    disabledReason = "headless environment")
```

---