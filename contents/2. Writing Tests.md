## 2.2 Definitions
### Lifecycle Method
@BeforeAll, @AfterAll, @BeforeEach, @AfterEach

### Test Class
Test class ëŠ” abstract ì—¬ì„œëŠ” ì•ˆë˜ë©°, ë‹¨ í•˜ë‚˜ì˜ ìƒì„±ì(constructor)ë¥¼ ê°€ì ¸ì•¼ í•œë‹¤.
1. ìµœìƒìœ„ class
2. static member class 
3. @Nested ë¡œ ì •ì˜ë˜ê³  í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ í•˜ë‚˜ì´ìƒ ê°€ì§€ê³  ìˆëŠ” class


## 2.3 Test Classes and Methods
test í•¨ìˆ˜ì™€ lifecycle í•¨ìˆ˜ëŠ” í˜„ì¬ class ë‚´ë¶€ì— ì„ ì–¸ë˜ê±°ë‚˜, ë¶€ëª¨ í´ë˜ìŠ¤ë‚˜ interface ë¡œ ë¶€í„° ìƒì† ë°›ëŠ”ë‹¤.
ë§ ë¶™ì—¬, í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ì™€ ë¼ì´í”„ ì‚¬ì´í´ í•¨ìˆ˜ëŠ” ì¶”ìƒ í•¨ìˆ˜ë¡œ ì„ ì–¸ ë  ìˆ˜ ì—†ìœ¼ë©´ return value ë¥¼ ê°€ì§ˆ ìˆ˜ ì—†ë‹¤. 

---
_Class ì™€ methodì˜ ê°€ì‹œì„±
test class, test í•¨ìˆ˜, lifecycle í•¨ìˆ˜ëŠ” public ì¼ í•„ìš”ëŠ” ì—†ìœ¼ë‚˜ privateë¡œ ì„ ì–¸ë˜ì„œëŠ” ì•ˆëœë‹¤.<br/>
ì¼ë°˜ì ìœ¼ë¡œ, ë‹¤ë¥¸ packageì—ì„œ test classë‚˜ test í•¨ìˆ˜, lifecycle í•¨ìˆ˜ ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ë¥¼ ì œì™¸í•˜ê³  public ìˆ˜ì •ìë¥¼ ìƒëµí•˜ëŠ”ê²ƒì„ ì¶”ì²œí•œë‹¤._
---
ì¼ë°˜ì ì¸ test í•¨ìˆ˜ì™€ lifecycle í•¨ìˆ˜ì˜ ì‚¬ìš© ë°©ë²•ì€ ì•„ë˜ì™€ ê°™ë‹¤.
```java
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {
    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @Test
    void abortedTest() {
        assumeTrue("abc".contains("Z"));
        fail("test should have been aborted");
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }
}
```


## 2.4 Display Names
test class ì™€ test í•¨ìˆ˜ëŠ” @DisplayName ì–´ë…¸í…Œì´ì…˜ì„ í†µí•´ í‘œì‹œë˜ëŠ” í…ŒìŠ¤íŠ¸ ëª…(display name)ì„ ë³€ê²½ í•  ìˆ˜ ìˆë‹¤. í‘œì‹œ í•  ìˆ˜ ìˆëŠ” í…ŒìŠ¤íŠ¸ ëª…ì€ ê³µë°±, íŠ¹ìˆ˜ë¬¸ì, ì´ëª¨ì§€ ê¹Œì§€ ê°€ëŠ¥í•˜ê³ , ë³€ê²½í•œ í…ŒìŠ¤íŠ¸ ëª…ì€ í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œë‚˜, í…ŒìŠ¤íŠ¸ ì‹¤í–‰ê¸°, IDE ì—ì„œ í‘œì‹œ ëœë‹¤.

```java
@DisplayName("A special test case")
class DisplayNameDemo {

    @Test
    @DisplayName("Custom test name containing spaces")
    void testWithDisplayNameContainingSpaces() {
    }

    @Test
    @DisplayName("â•¯Â°â–¡Â°ï¼‰â•¯")
    void testWithDisplayNameContainingSpecialCharacters() {
    }

    @Test
    @DisplayName("ğŸ˜±")
    void testWithDisplayNameContainingEmoji() {
    }

}
```

### 2.4.1. Display Name Generators
JUnit JupiterëŠ” @DisplayNameGeneration ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•˜ëŠ” custom display name ìƒì„±ê¸°ë¥¼ ì§€ì›í•œë‹¤.  
@DisplayNameì˜ ê°’ì´ @DisplayNameGenerationë¥¼ í†µí•´ ìƒì„±ëœ ê°’ ë³´ë‹¤ í•­ìƒ ìš°ì„ í•œë‹¤.

DisplayNameGeneratorë¥¼ êµ¬í˜„í•¨ ìœ¼ë¡œì„œ ìƒì„±ê¸°ë¥¼ ë§Œ ë“¤ ìˆ˜ ìˆë‹¤.  
ì•„ë˜ëŠ” Jupiterì—ì„œ ê¸°ë³¸ì„ ì œê³µí•˜ëŠ” ìƒì„±ê¸° ë“¤ì´ë‹¤.

|DisplayNameGenerator| Behavior                                                 |
|---|----------------------------------------------------------|
|Standard| Junit Jupiter 5.0ì´ ì¶œì‹œ ëœ ì´í›„ ì‚¬ìš©ë˜ì–´ì˜¤ê³  ìˆëŠ” ê¸°ë³¸ display name ìƒì„±ê¸° |
|Simple| íŒŒë¼ë¯¸í„°ê°€ ì—†ëŠ” í•¨ìˆ˜ì˜ ê´„í˜¸ë¥¼ ì‚­ì œ í•˜ëŠ” ìƒì„±ê¸°                               |
|ReplaceUnderscores| ë°‘ì¤„(underscore)ì„ ê³µë°±(space)ë¡œ ë³€í™˜í•˜ëŠ” ìƒì„±ê¸°                      |
|IndicativeSentences| testì™€ ì´ë¥¼ í¬í•¨í•˜ëŠ” class ëª…ì„ í•©ì³ì„œ ì™„ì„±ëœ ë¬¸ì¥ì„ ìƒì„±í•˜ëŠ” ìƒì„±ê¸°              |

@IndicativeSentencesGeneration ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•˜ë©´, IndicativeSentences ê¸°ëŠ¥ì— separator(ê¸°ë³¸ì€ ", ")ì™€ ê¸°ë³¸ display name ìƒì„±ê¸°ë¥¼ ë³„ë„ë¡œ ì •ì˜ í•  ìˆ˜ ìˆë‹¤.
```java
class DisplayNameGeneratorDemo {

    @Nested
    @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_not_supported {

        @Test
        void if_it_is_zero() {}
//        if it is zero

        @DisplayName("A negative value for year is not supported by the leap year computation.")
        @ParameterizedTest(name = "For example, year {0} is not supported.")
        @ValueSource(ints = { -1, -4 })
        void if_it_is_negative(int year) {}
//        A negative value for year is not supported by the leap year computation.
//            For example, year -1 is not supported.
//            For example, year -4 is not supported.
    }

    @Nested
    @IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
    class A_year_is_a_leap_year {

        @Test
        void if_it_is_divisible_by_4_but_not_by_100() {
        }
//        A year is a leap year -> if it is divisible by 4 but not by 100

        @ParameterizedTest(name = "Year {0} is a leap year.")
        @ValueSource(ints = { 2016, 2020, 2048 })
        void if_it_is_one_of_the_following_years(int year) {
        }
//        A year is a leap year -> if it is one of the following years
//            Year 2016 is a leap year
//            Year 2020 is a leap year
//            Year 2048 is a leap year        
    }

}
```

### 2.4.2. Setting the Default Display Name Generator
junit ì†ì„± íŒŒì¼ (src/test/resources/junit-platform.properties) ì— "junit.jupiter.displayname.generator.default"ê°’ì„ ì´ìš©í•˜ì—¬ ê¸°ë³¸ display name ìƒì„±ê¸°ë¥¼ ì„¤ì • í•  ìˆ˜ ìˆë‹¤.  
@DisplayNameGeneration ì–´ë…¸í…Œì´ì…˜ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ì„¤ì • ê°’ ë³´ë‹¤ @DisplayName ì–´ë…¸í…Œì´ì…˜ì˜ ê°’ì´ ë” ìš°ì„ í•˜ë©°, ì‚¬ìš©ìê°€ DisplayNameGeneratorë¥¼ êµ¬í˜„í•˜ì—¬ ìƒì„±í•œ ì‚¬ìš©ì ì •ì˜ display name ìƒì„±ê¸° í´ë˜ìŠ¤ë„ ì ìš© ê°€ëŠ¥í•˜ë‹¤.  
```properties
junit.jupiter.displayname.generator.default = org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
```

## 2.5. Assertions
JUnit Jupiter ì—ì„œëŠ” Junit 4ì—ì„œ ì‚¬ìš©í•˜ë˜ assertion í•¨ìˆ˜ì— Java 8 lambda ì‚¬ìš©ì— ì í•©í•œ í•¨ìˆ˜ë“¤ì´ ì¶”ê°€ ë˜ì—ˆë‹¤. 
Junit Jupiterì˜ ëª¨ë“  assertionì€ org.junit.jupiter.api.Assertions í´ë˜ìŠ¤ì— static í•¨ìˆ˜ë¡œ ì •ì˜ ë˜ì–´ ìˆë‹¤.

```java
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.CountDownLatch;

import example.domain.Person;
import example.util.Calculator;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

class AssertionsDemo {

    private final Calculator calculator = new Calculator();

    private final Person person = new Person("Jane", "Doe");

    @Test
    void standardAssertions() {
        assertEquals(2, calculator.add(1, 1));        
//        ë§ˆì§€ë§‰ íŒŒë¼ë¯¸í„°ë¡œ ì‹¤íŒ¨ ë©”ì‹œì§€ë¥¼ ì „ë‹¬ í•  ìˆ˜ ìˆë‹¤.
        assertEquals(4, calculator.multiply(2, 2), "The optional failure message is now the last parameter");
//        supplierë¥¼ ì´ìš©í•˜ì—¬ ì‹¤íŒ¨ ë©”ì‹œì§€ë¥¼ ì§€ì—° í•  ìˆ˜ ìˆë‹¤.
        assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- " + "to avoid constructing complex messages unnecessarily.");
    }

    @Test
    void groupedAssertions() {
//        assertAll ì„ ì´ìš©í•´ì„œ ë³µìˆ˜ê±´ì„ í•œë²ˆì— ê²€ì¦ í•  ìˆ˜ ìˆë‹¤.
        assertAll("person",
            () -> assertEquals("Jane", person.getFirstName()),
            () -> assertEquals("Doe", person.getLastName())
        );
    }

    @Test
    void dependentAssertions() {
        assertAll("properties",
            () -> {
//                ì½”ë“œë¸”ë¡ ì•ˆì— assertion ì½”ë“œë¥¼ ì‘ì„±í•œ ê²½ìš°, assertionì´ ì‹¤íŒ¨í•˜ë©´ ì´í›„ ì½”ë“œëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤. ëª¨ë“  assertion ì´ ì„±ê³µí•œ ì´í›„ ì½”ë“œê°€ ì‹¤í–‰ëœë‹¤.
                String firstName = person.getFirstName();
                assertNotNull(firstName);
                assertEquals("Jane", firstName);
                
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("e"))
                );
            },
            () -> {
//                assertAll ì˜ ê° ê°œë³„ assertionì€ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì—, assertionì´ ì‹¤íŒ¨í•˜ë”ë¼ë„ ì´í›„ assertionì€ ì‹¤í–‰ëœë‹¤.
//                ì•„ë˜ ì½”ë“œëŠ” ìœ„ì˜ firstName assertionì´ ì‹¤íŒ¨í•˜ë”ë¼ë„ ì‹¤í–‰ëœë‹¤.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }

    @Test
    void exceptionTesting() {
//        ë°œìƒì´ ì˜ˆìƒë˜ëŠ” Exception ì„ assertThrows ì˜ ì²«ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬í•˜ê³ , ë‘ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¡œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ëŠ” ì½”ë“œë¥¼ ëŒë‹¤ë¡œ ì „ë‹¬í•˜ì—¬
//        ì˜ˆìƒí•œ Exception ì´ ë°œìƒí•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.
        Exception exception = assertThrows(ArithmeticException.class, () ->
            calculator.divide(1, 0));
        assertEquals("/ by zero", exception.getMessage());
    }

    @Test
    void timeoutNotExceeded() {
//        ì½”ë“œì‹¤í–‰ ì‹œê°„ì´ 2ì´ˆë¥¼ ë„˜ê¸°ë©´ assertion ì‹¤íŒ¨í•œë‹¤.
        assertTimeout(Duration.ofSeconds(2), () -> {
            Thread.sleep(1000);
        });
    }
    
    @Test
    void timeoutNotExceededWithResult() {
//        ì½”ë“œê°€ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆì— ê²°ê³¼ê°’ì„ ë¦¬í„´í•˜ëŠ” ê²½ìš°, ë¦¬í„´ëœ ê²°ê³¼ê°’ì„ assertion í•  ìˆ˜ ìˆë‹¤.
//        Timeout ì´ ë°œìƒí•˜ë©´ assertion ì‹¤íŒ¨í•˜ê³  í…ŒìŠ¤íŠ¸ ì¢…ë£Œë˜ë©°, Timeout ì´ ë°œìƒí•˜ì§€ ì•Šìœ¼ë©´ ë¦¬í„´ëœ ê²°ê³¼ê°’ì„ assertion í•œë‹¤.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
            return "a result";
        });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
//        method ì°¸ì¡°ë¥¼ ì´ìš©í•˜ì—¬ assertion í•  ìˆ˜ ìˆë‹¤.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("Hello, World!", actualGreeting);
    }
    
    @Test
    void timeoutExceededWithPreemptiveTermination() {
//        timeoutExceededWithPreemptiveTermination í•¨ìˆ˜ë¥¼ ì´ìš©í•´ì„œ assertTimeout ê³¼ ê°™ì€ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰ í•  ìˆ˜ ìˆë‹¤.
//        timeoutExceededWithPreemptiveTerminationê°€ assertTimeout ê³¼ ë‹¤ë¥¸ ì ì€ ì•„ë˜ ì„¤ëª… ì°¸ê³ 
        assertTimeoutPreemptively(ofMillis(10), () -> {
            new CountDownLatch(1).await();
        });
    }

    private static String greeting() {
        return "Hello, World!";
    }

}
```

---
_assertTimeoutPreemptively() í•¨ìˆ˜ë¥¼ ì´ìš©í•œ ì„ ì œì  íƒ€ì„ì•„ì›ƒ  
Assertions í´ë˜ìŠ¤ì— ìˆëŠ” ë‹¤ì–‘í•œ assertTimeoutPreemptively()ëŠ” Executable íƒ€ì…ì´ë‚˜ Supplier íƒ€ì…ì„ í˜¸ì¶œí•˜ëŠ” ì½”ë“œì™€ ë¶„ë¦¬ëœ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰í•œë‹¤. Executableì´ë‚˜ Supplierì˜ ì½”ë“œê°€ java.lang.ThreadLocal storageë¥¼ ì´ìš©í•˜ëŠ” ê²½ìš° ë¶€ì‘ìš©ì„ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤.  
Spring Framework ì—ì„œ ì§€ì›í•˜ëŠ” íŠ¸ëœì­ì…˜ í…ŒìŠ¤íŠ¸ê°€ ëŒ€í‘œì ì¸ ì˜ˆ ì´ë‹¤.  
íŠ¹ë³„íˆ ìŠ¤í”„ë§ í…ŒìŠ¤íŠ¸ëŠ”  í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ê°€ ì‹¤í–‰ ë˜ê¸° ì „ì— TreadLocalì„ ì´ìš©í•´ íŠ¸ëœì­ì…˜ ìƒíƒœë¥¼ í˜„ì¬ ìŠ¤ë ˆë“œì— ë°”ì¸ë”© í•œë‹¤.  
ê²°ê³¼ì ìœ¼ë¡œ, assertTimeoutPreemptively()í•¨ìˆ˜ì— ì œê³µëœ Excutableì´ë‚˜ Sullpierê°€ íŠ¸ëœì­ì…˜ì— í¬í•¨ë˜ëŠ” ìŠ¤í”„ë§ ê´€ë¦¬ ì½¤í¬ë„ŒíŠ¸ë¥¼ ì‹¤í–‰í•œë‹¤ë©´, ì½¤í¬ë„ŒíŠ¸ê°€ ìˆ˜í–‰í•˜ëŠ” ì–´ë–¤ í–‰ë™ë“¤ë„ testì—ì„œ ê´€ë¦¬ë˜ëŠ” íŠ¸ëœì­ì…˜ê³¼ í•¨ê»˜ ë¡¤ë°±ë˜ì§€ ì•ŠëŠ”ë‹¤.
ì´ì™€ ë°˜ëŒ€ë¡œ, test ê´€ë¦¬ íŠ¸ëœì­ì…˜ì´ ë¡¤ë°±ëœë‹¤ í•˜ë”ë¼ë„, í•´ë‹¹ í–‰ë™ë“¤ì€ dbì™€ ê°™ì€ persistent sotreì— ì»¤ë°‹ ëœë‹¤.  
ThreadLocal storageë¥¼ ì´ìš©í•˜ëŠ” ë‹¤ë¥¸ í”„ë ˆì„ì›ë“¤ë„ ë¹„ìŠ·í•œ ë¶€ì‘ìš©ì„ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤._
---

### 2.5.1. Kotlin Assertion Support
JUnit Jupiter ëŠ” Kotlinì— ì í•©í•œ assertion í•¨ìˆ˜ë„ ì¼ë¶€ ì§€ì›í•˜ê³ , ì´ëŠ” JUnit Jupiterì˜ org.junit.jupiter.api íŒ¨í‚¤ì§€ì˜ ìµœ ìƒìœ„ í•¨ìˆ˜ë¡œ ë˜ì–´ ìˆë‹¤.  
Kotlin ê´€ë ¨ ë‚´ìš©ì€ ì¼ë‹¨ íŒ¨ìŠ¤~~~

```kotlin
import example.domain.Person
import example.util.Calculator
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertAll
import org.junit.jupiter.api.assertDoesNotThrow
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.assertTimeout
import org.junit.jupiter.api.assertTimeoutPreemptively
import java.time.Duration

class KotlinAssertionsDemo {

    private val person = Person("Jane", "Doe")
    private val people = setOf(person, Person("John", "Doe"))

    @Test
    fun `exception absence testing`() {
        val calculator = Calculator()
        val result = assertDoesNotThrow("Should not throw an exception") {
            calculator.divide(0, 1)
        }
        assertEquals(0, result)
    }

    @Test
    fun `expected exception testing`() {
        val calculator = Calculator()
        val exception = assertThrows<ArithmeticException> ("Should throw an exception") {
            calculator.divide(1, 0)
        }
        assertEquals("/ by zero", exception.message)
    }

    @Test
    fun `grouped assertions`() {
        assertAll(
            "Person properties",
            { assertEquals("Jane", person.firstName) },
            { assertEquals("Doe", person.lastName) }
        )
    }

    @Test
    fun `grouped assertions from a stream`() {
        assertAll(
            "People with first name starting with J",
            people
                .stream()
                .map {
                    // This mapping returns Stream<() -> Unit>
                    { assertTrue(it.firstName.startsWith("J")) }
                }
        )
    }

    @Test
    fun `grouped assertions from a collection`() {
        assertAll(
            "People with last name of Doe",
            people.map { { assertEquals("Doe", it.lastName) } }
        )
    }

    @Test
    fun `timeout not exceeded testing`() {
        val fibonacciCalculator = FibonacciCalculator()
        val result = assertTimeout(Duration.ofMillis(1000)) {
            fibonacciCalculator.fib(14)
        }
        assertEquals(377, result)
    }

    @Test
    fun `timeout exceeded with preemptive termination`() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(Duration.ofMillis(10)) {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100)
        }
    }
}
```

### 2.5.2. Third-party Assertion Libraries
JUnit Jupiterì— ì˜í•´ ì œê³µë˜ëŠ” assertion ê¸°ëŠ¥ë“¤ì´ ë§ì€ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ì— ì í•©í•˜ë‹¤ í•˜ë”ë¼ë„, ë•Œë•Œë¡œ matcherì™€ ê°™ì€ ì¶”ê°€ ê¸°ëŠ¥ë“¤ì´ í•„ìš”í•œ ê²½ìš°ê°€ ìˆë‹¤.
ê·¸ëŸ° ê²½ìš°, JUnit íŒ€ì€ AssertJ, Hamcrest, Truth ë“±ì˜ ì„œë“œíŒŒí‹° assertion ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•  ê²ƒì„ ê¶Œì¥í•œë‹¤.

ì˜ˆë¡œ, matcherì™€ fluent APIì˜ ì¡°í•©ì€ assertionì„ ë” ìì„¸í•˜ê³  ì½ê¸° ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë‚˜ Junit 4ì—ì„œ ì§€ì›í•˜ê³  Hamcrest Matcherì—ì„œ ì±„íƒëœ assertThat() í•¨ìˆ˜ëŠ” JUnit Jupiterì—ì„œëŠ” ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤.
ëŒ€ì‹ , ê°œë°œìë“¤ì€ ì„œë“œíŒŒí‹° assertion ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µí•˜ëŠ” matcherë¥¼ ì‚¬ìš©í•  ê²ƒì„ ê¶Œì¥í•œë‹¤. 

ì•„ë˜ ì˜ˆì œëŠ” JUnit Jupiter í…ŒìŠ¤íŠ¸ì—ì„œ Hamcrestì˜ assertThat() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤€ë‹¤. Hamcrest ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ classpathì— ì¶”ê°€ë˜ì–´ ìˆëŠ”í•œ, assertThat(), is(), equalTo()ì™€ ê°™ì€ í•¨ìˆ˜ë“¤ì„ static import í•  ìˆ˜ ìˆê³ , ì•„ë˜ì˜ assertWithHamcrestMatcher() í•¨ìˆ˜ì²˜ëŸ¼ í…ŒìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```java
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class HamcrestAssertionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void assertWithHamcrestMatcher() {
        assertThat(calculator.subtract(4, 1), is(equalTo(3)));
    }

}
```
ë¬¼ë¡ , JUnit 4 í”„ë¡œê·¸ë˜ë° ëª¨ë¸ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ë ˆê±°ì‹œ í…ŒìŠ¤íŠ¸ëŠ” org.junit.Assert#assertThatì„ ê³„ì† ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.


## 2.6. Assumptions
JUnit Jupiter ì—ëŠ” JUnit 4ì—ì„œ ì œê³µí•˜ëŠ” assumption ë©”ì†Œë“œì˜ í•˜ìœ„ ì§‘í•©ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©°, Java 8 ëŒë‹¤ í‘œí˜„ì‹ê³¼ ë©”ì†Œë“œ ì°¸ì¡°ë¥¼ ì‚¬ìš©í•˜ëŠ” ë° ì í•©í•œ ëª‡ ê°€ì§€ ë©”ì†Œë“œê°€ ì¶”ê°€ë˜ì—ˆë‹¤. 
ëª¨ë“  JUnit Jupiter assumption ë©”ì†Œë“œëŠ” org.junit.jupiter.api.Assumptions í´ë˜ìŠ¤ì— static ìœ¼ë¡œ ì •ì˜ ë˜ì–´ ìˆë‹¤.

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.junit.jupiter.api.Assumptions.assumingThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssumptionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void testOnlyOnCiServer() {
        assumeTrue("CI".equals(System.getenv("ENV")));
    }

    @Test
    void testOnlyOnDeveloperWorkstation() {
//        í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í•˜ë©´, í…ŒìŠ¤íŠ¸ëŠ” ì‹¤íŒ¨ë¡œ í‘œì‹œë˜ì§€ ì•Šê³ , ë¬´ì‹œëœë‹¤.
//        í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í•  ê²½ìš° "Assumption failed: Aborting test: not on developer workstation" ë©”ì‹œì§€ê°€ í‘œì‹œëœë‹¤.
        assumeTrue("DEV".equals(System.getenv("ENV")),
                () -> "Aborting test: not on developer workstation");
    }

    @Test
    void testInAllEnvironments() {
//        ì²«ë²ˆì§¸ íŒŒë¼ë¯¸í„°ê°€ true ì¼ ê²½ìš°, ë‘ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬ëœ ëŒë‹¤ í‘œí˜„ì‹ì´ ì‹¤í–‰ëœë‹¤.
//        ì²œë²ˆì§¸ íŒŒë¼ë¯¸í„°ê°€ false ì¼ ê²½ìš°, ë‘ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬ëœ ëŒë‹¤ í‘œí˜„ì‹ì€ ë¬´ì‹œ ëœë‹¤.
        assumingThat("CI".equals(System.getenv("ENV")),
                () -> {
                    assertEquals(2, calculator.divide(4, 2));
                });

        // System.getenv("ENV") ê°€ CI ì´ë˜ ì•„ë‹ˆë˜, (ì¤‘ê°„ì— assertion ì´ ì‹¤íŒ¨í•˜ì§€ ì•ŠëŠ” ì´ìƒ) ë¬´ì¡°ê±´ ì‹¤í–‰ ëœë‹¤.
        assertEquals(42, calculator.multiply(6, 7));
    }

}
```

---
_JUnit Jupiter 5.4 ì´í›„ë¡œ, JUnit 4ì˜ org.junit.Assume í´ë˜ìŠ¤ì˜ ë©”ì†Œë“œë¥¼ assumptionìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. íŠ¹íˆ, JUnit JupiterëŠ” JUnit 4ì˜ AssumptionViolatedExceptionì„ ì§€ì›í•˜ì—¬ í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨ë¡œ í‘œì‹œë˜ëŠ” ëŒ€ì‹  í…ŒìŠ¤íŠ¸ê°€ ì¤‘ë‹¨ë˜ì–´ì•¼ í•¨ì„ ë‚˜íƒ€ë‚¸ë‹¤._

---


## 2.7. Disabling Tests
í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë‚˜ ê°œë³„ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ ë¹„ í™œì„±í™” ì‹œí‚¤ëŠ” ë°©ë²•
1. @Disabled ì–´ë…¸í…Œì´ì…˜
2. Conditional Test Execution ì—ì„œ ì„¤ëª…í•œ ì–´ë…¸í…Œì´ì…˜ ì‚¬ìš©
3. ì‚¬ìš©ì ì •ì˜ ExecutionConditionì„ ì‚¬ìš©

@Disabled ì˜ˆì œ
```java
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

public class DisabledDemo {
    @Disabled("Disabled until bug #42 has been resolved")
    @Test
    void testWillBeSkipped() {
    }

    @Test
    void testWillBeExecuted() {
    }

    @Disabled
    @Nested
    class DisabledTestClass {
        @Test
        void testWillBeSkipped() {
        }
    }

    @Nested
    class EnsabledTestClass {
        @Test
        void testWillBeExecuted() {
        }
    }

}
```
---
_@Disabledë¥¼ ì‚¬ìš©í• ë•Œ ì´ìœ ë¥¼ ì‘ì„± í•˜ì§€ ì•Šì•„ë„ ëœë‹¤. í•˜ì§€ë§Œ JUnit íŒ€ì€ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë‚˜ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ê°€ ì™œ ë¹„í™œì„±í™” ë˜ì—ˆëŠ”ì§€ì— ëŒ€í•œ ê°„ë‹¨í•œ ì„¤ëª…ì„ ì‘ì„±í•  ê²ƒì„ ê¶Œì¥í•œë‹¤._ 

---


## 2.8. Conditional Test Execution
JUnit Jupiterì˜ ExecutionCondition í™•ì¥ APIëŠ” íŠ¹ì • ì¡°ê±´ì— ë”°ë¼ ì»¨í…Œì´ë„ˆë‚˜ í…ŒìŠ¤íŠ¸ ë² ì´ìŠ¤ë¥¼ í”„ë¡œê·¸ë¨ì ìœ¼ë¡œ í™œì„±í™”, ë¹„í™œì„±í™” í•  ìˆ˜ ìˆë‹¤.
ì¡°ê±´ì„ ì§€ì •í•˜ëŠ” ê°€ì¥ ê°„ë‹¨í•œ ì˜ˆëŠ” @Disabled ì–´ë…¸í…Œì´ì…˜ì„ ì§€ì›í•˜ëŠ” DisabledConditionì´ë‹¤. (Disabling Tests ì°¸ê³ )
JUnit JupiterëŠ” @Disabledì™¸ì—ë„ ì–´ë…¸í…Œì´ì…˜ ê¸°ë°˜ì˜ ëª‡ê°€ì§€ ì¡°ê±´(org.junit.jupiter.api.condition)ì„ ì§€ì›í•œë‹¤. ì´ ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ë©´ ê°œë°œìê°€ ì„ ì–¸ì ìœ¼ë¡œ ì»¨í…Œì´ë„ˆë‚˜ í…ŒìŠ¤íŠ¸ë¥¼ í™œì„±í™”, ë¹„í™œì„±í™” í•  ìˆ˜ ìˆë‹¤.
ë³µìˆ˜ê°œì˜ ExecutionCondition ì´ ë“±ë¡ë˜ëŠ” ê²½ìš°, ì»¨í…Œì´ë„ˆë‚˜ í…ŒìŠ¤íŠ¸ëŠ” í•˜ë‚˜ì˜ ì¡°ê±´ì´ë¼ë„ ë¹„í™œì„±í™” ë˜ë©´ ë¹„í™œì„±í™” ëœë‹¤.
ë§Œì•½ ë¹„í™œì„±í™” ëœ ì´ìœ ë¥¼ ì œê³µí•˜ê³  ì‹¶ë‹¤ë©´, ê°ê°ì˜ ì–´ë…¸í…Œì´ì…˜ì—ëŠ” disabledReason ì†ì„±ì„ ì‘ì„±í•˜ë©´ ëœë‹¤.

---
_**Composed Annotations**  
ì´í›„ì— ì‘ì„±ëœ ì¡°ê±´ ì–´ë…¸í…Œì´ì…˜ë“¤ ì—­ì‹œ ì‚¬ìš©ì ì •ì˜ ì–´ë…¸í…Œì´ì…˜ì„ ìƒì„±í•˜ê¸° ìœ„í•œ meta-annotationìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
ì˜ˆë¥¼ ë“¤ì–´, @TestOnMac ì–´ë…¸í…Œì´ì…˜ì€ @Testì™€ @EnabledOnOsë¥¼ ì¡°í•©í•œ ì–´ë…¸í…Œì´ì…˜ì´ë‹¤._

---

---
_ë‹¬ë¦¬ ëª…ì‹œë˜ì§€ ì•ŠëŠ” í•œ, ë‹¤ìŒ ì„¹ì…˜ì— ë‚˜ì—´ëœ ê° ì¡°ê±´ ì–´ë…¸í…Œì´ì…˜ì€ í…ŒìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤, í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ ë˜ëŠ” í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œì—ì„œ í•œ ë²ˆë§Œ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤. ì¡°ê±´ ì–´ë…¸í…Œì´ì…˜ì´ ì§ì ‘ì ìœ¼ë¡œ, ê°„ì ‘ì ìœ¼ë¡œ ë˜ëŠ” ë©”íƒ€ë¡œ í•œ ìš”ì†Œì— ì—¬ëŸ¬ ë²ˆ ì¡´ì¬í•˜ëŠ” ê²½ìš°, JUnitì— ì˜í•´ ë°œê²¬ëœ ì²« ë²ˆì§¸ ì–´ë…¸í…Œì´ì…˜ë§Œ ì‚¬ìš©ëœë‹¤. ì¶”ê°€ ì„ ì–¸ì€ ë¬´ì‹œëœë‹¤.  
ê·¸ëŸ¬ë‚˜, ê° ì¡°ê±´ ì–´ë…¸í…Œì´ì…˜ì€ org.junit.jupiter.api.condition íŒ¨í‚¤ì§€ì˜ ë‹¤ë¥¸ ì¡°ê±´ ì–´ë…¸í…Œì´ì…˜ê³¼ í•¨ê»˜ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤._

---

### 2.8.1. Operating System and Architecture Conditions
ì»¨í…Œì´ë„ˆ ë‚˜ í…ŒìŠ¤íŠ¸ëŠ” @EnabledOnOsì™€ @DisabledOnOs ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•´ì„œ íŠ¹ì • ìš´ì˜ì²´ì œë‚˜ ì•„í‚¤í…ì²˜ì—ì„œë§Œ ì‹¤í–‰ë˜ë„ë¡ ì§€ì •í•  ìˆ˜ ìˆë‹¤.

_Conditional execution based on operating system_
```java
@Test
@EnabledOnOs(MAC)
void onlyOnMacOs() {
    // ...
}

@TestOnMac
void testOnMac() {
    // ...
}

@Test
@EnabledOnOs({ LINUX, MAC })
void onLinuxOrMac() {
    // ...
}

@Test
@DisabledOnOs(WINDOWS)
void notOnWindows() {
    // ...
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Test
@EnabledOnOs(MAC)
@interface TestOnMac {
}
```
_Conditional execution based on architecture_
```java
@Test
@EnabledOnOs(architectures = "aarch64")
void onAarch64() {
    // ...
}

@Test
@DisabledOnOs(architectures = "x86_64")
void notOnX86_64() {
    // ...
}

@Test
@EnabledOnOs(value = MAC, architectures = "aarch64")
void onNewMacs() {
    // ...
}

@Test
@DisabledOnOs(value = MAC, architectures = "aarch64")
void notOnNewMacs() {
    // ...
}
```

### 2.8.2. Java Runtime Environment Conditions
ì»¨í…Œì´ë„ˆë‚˜ í…ŒìŠ¤íŠ¸ëŠ” @EnabledOnJreì™€ @DisabledOnJre ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•´ì„œ íŠ¹ì • ë²„ì „ì˜ ìë°” ëŸ°íƒ€ì„ í™˜ê²½ì—ì„œë§Œ ì‹¤í–‰ë˜ë„ë¡ ì§€ì •í•˜ê±°ë‚˜, @EnabledForJreRangeì™€ @DisabledForJreRange ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•´ì„œ ì‹¤í–‰ë˜ê±°ë‚˜ ì‹¤í–‰ë˜ì§€ ì•Šì„ JREì˜ ë²”ìœ„ë¥¼ ì§€ì • í•  ìˆ˜ ìˆë‹¤. ë²”ìœ„ëŠ” JRE.JAVA_8ì„ í•˜í•œ (min)ìœ¼ë¡œ JRE.OTHERë¥¼ ìƒí•œ (max)ìœ¼ë¡œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ë©°, ë°˜ ê°œë°© ë²”ìœ„ì˜ ì‚¬ìš©ì„ í—ˆìš©í•œë‹¤.

```java
@Test
@EnabledOnJre(JAVA_8)
void onlyOnJava8() {
    // ...
}

@Test
@EnabledOnJre({ JAVA_9, JAVA_10 })
void onJava9Or10() {
    // ...
}

@Test
@EnabledForJreRange(min = JAVA_9, max = JAVA_11)
void fromJava9to11() {
    // ...
}

@Test
@EnabledForJreRange(min = JAVA_9)
void fromJava9toCurrentJavaFeatureNumber() {
    // ...
}

@Test
@EnabledForJreRange(max = JAVA_11)
void fromJava8To11() {
    // ...
}

@Test
@DisabledOnJre(JAVA_9)
void notOnJava9() {
    // ...
}

@Test
@DisabledForJreRange(min = JAVA_9, max = JAVA_11)
void notFromJava9to11() {
    // ...
}

@Test
@DisabledForJreRange(min = JAVA_9)
void notFromJava9toCurrentJavaFeatureNumber() {
    // ...
}

@Test
@DisabledForJreRange(max = JAVA_11)
void notFromJava8to11() {
    // ...
}
```

### 2.8.3. Native Image Conditions
@EnabledInNativeImage, @DisabledInNativeImage ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•˜ì—¬ ì»¨í…Œì´ë„ˆë‚˜ í…ŒìŠ¤íŠ¸ê°€ GraalVM ë„¤ì´í‹°ë¸Œ ì´ë¯¸ì§€ì—ì„œë§Œ ì‹¤í–‰ë˜ë„ë¡ ì§€ì •í•  ìˆ˜ ìˆë‹¤.
ì´ëŸ¬í•œ ì–´ë…¸í…Œì´ì…˜ì€ ì¼ë°˜ì ìœ¼ë¡œ GraalVM Native Build Tools í”„ë¡œì íŠ¸ì˜ Gradleê³¼ Maven í”ŒëŸ¬ê·¸ì¸ì„ ì‚¬ìš©í•˜ì—¬ ë„¤ì´í‹°ë¸Œ ì´ë¯¸ì§€ ë‚´ì—ì„œ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•  ë•Œ ì‚¬ìš©ëœë‹¤.

```java
@Test
@EnabledInNativeImage
void onlyWithinNativeImage() {
    // ...
}

@Test
@DisabledInNativeImage
void neverWithinNativeImage() {
    // ...
}
```

### 2.8.4. System Property Conditions
@EnabledIfSystemProperty ì™€ @DisabledIfSystemProperty annotationsì„ ì´ìš©í•˜ì—¬ JVM í™˜ê²½ ë³€ìˆ˜ì˜ ê°’ì— ë”°ë¼ í…ŒìŠ¤íŠ¸ë¥¼ í™œì„±í™” ë˜ëŠ” ë¹„í™œì„±í™” í•  ìˆ˜ ìˆë‹¤.
matches ì†ì„±ìœ¼ë¡œ ì§€ì •ëœ ê°’ì€ ì •ê·œ í‘œí˜„ì‹ìœ¼ë¡œ í•´ì„ëœë‹¤.

```java
@Test
@EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*")
void onlyOn64BitArchitectures() {
    // ...
}

@Test
@DisabledIfSystemProperty(named = "ci-server", matches = "true")
void notOnCiServer() {
    // ...
}
```
---
_JUnit Jupiter 5.6 ì´í›„, @EnabledIfSystemProperty ì™€ @DisabledIfSystemPropertyëŠ” ë°˜ë³µ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤.
ë”°ë¼ì„œ ì´ëŸ¬í•œ ì–´ë…¸í…Œì´ì…˜ì€ í…ŒìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤, í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ ë˜ëŠ” í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œì— ì—¬ëŸ¬ ë²ˆ ì„ ì–¸ë  ìˆ˜ ìˆë‹¤.
íŠ¹íˆ, ì´ëŸ¬í•œ ì–´ë…¸í…Œì´ì…˜ì€ ì§ì ‘ì , ê°„ì ‘ì  ë˜ëŠ” ë©”íƒ€ë¡œ ì„ ì–¸ë  ìˆ˜ ìˆë‹¤._

---

### 2.8.5. Environment Variable Conditions
@EnabledIfEnvironmentVariable, @DisabledIfEnvironmentVariable ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•´ì„œ OS í™˜ê²½ ë³€ìˆ˜ì˜ ê°’ì— ë”°ë¼ í…ŒìŠ¤íŠ¸ë¥¼ í™œì„±í™” ë˜ëŠ” ë¹„í™œì„±í™” í•  ìˆ˜ ìˆë‹¤.
matches ì†ì„±ìœ¼ë¡œ ì§€ì •ëœ ê°’ì€ ì •ê·œ í‘œí˜„ì‹ìœ¼ë¡œ í•´ì„ëœë‹¤.

```java
@Test
@EnabledIfEnvironmentVariable(named = "ENV", matches = "staging-server")
void onlyOnStagingServer() {
    // ...
}

@Test
@DisabledIfEnvironmentVariable(named = "ENV", matches = ".*development.*")
void notOnDeveloperWorkstation() {
    // ...
}
```
---
_JUnit Jupiter 5.6 ì´í›„, @EnabledIfEnvironmentVariable ì™€ @DisabledIfEnvironmentVariableëŠ” ë°˜ë³µ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤.
ë”°ë¼ì„œ ì´ëŸ¬í•œ ì–´ë…¸í…Œì´ì…˜ì€ í…ŒìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤, í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ ë˜ëŠ” í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œì— ì—¬ëŸ¬ ë²ˆ ì„ ì–¸ë  ìˆ˜ ìˆë‹¤.
íŠ¹íˆ, ì´ëŸ¬í•œ ì–´ë…¸í…Œì´ì…˜ì€ ì§ì ‘ì , ê°„ì ‘ì  ë˜ëŠ” ë©”íƒ€ë¡œ ì„ ì–¸ë  ìˆ˜ ìˆë‹¤._

---

### 2.8.6. Custom Conditions
ExecutionConditionì„ êµ¬í˜„í•˜ëŠ” ëŒ€ì‹  @EnabledIf ì™€ @DisabledIf ì–´ë…¸í…Œì´ì…˜ì„ í†µí•´ ì¡°ê±´ ë©”ì†Œë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì»¨í…Œì´ë„ˆë‚˜ í…ŒìŠ¤íŠ¸ë¥¼ í™œì„±í™” ë˜ëŠ” ë¹„í™œì„±í™” í•  ìˆ˜ ìˆë‹¤.
ì¡°ê±´ ë©”ì†Œë“œëŠ” boolean ë°˜í™˜ íƒ€ì…ì„ ê°€ì ¸ì•¼ í•˜ë©° ì¸ìë¥¼ ë°›ì§€ ì•Šê±°ë‚˜ ë‹¨ì¼ ExtensionContext ì¸ìë¥¼ ë°›ì•„ì•¼ í•œë‹¤.

ì•„ë˜ í…ŒìŠ¤íŠ¸ëŠ” @EnabledIf ì™€ @DisabledIf ì–´ë…¸í…Œì´ì…˜ì— customCondition ë©”ì†Œë“œë¥¼ ì„¤ì •í•˜ì—¬ í…ŒìŠ¤íŠ¸ë¥¼ í™œì„±í™” ë˜ëŠ” ë¹„í™œì„±í™” í•˜ëŠ” ì˜ˆì œë¥¼ ë³´ì—¬ì¤€ë‹¤.


```java
@Test
@EnabledIf("customCondition")
void enabled() {
    // ...
}

@Test
@DisabledIf("customCondition")
void disabled() {
    // ...
}

boolean customCondition() {
    return true;
}
```
ì¡°ê±´ ë©”ì†Œë“œëŠ” í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ ì™¸ë¶€ì— ìœ„ì¹˜ í•  ìˆ˜ ìˆë‹¤. ì´ ê²½ìš° ë‹¤ìŒ ì˜ˆì œì™€ ê°™ì´ ì™„ì „íˆ ì •ê·œí™”ëœ ì´ë¦„ìœ¼ë¡œ ì°¸ì¡°ë˜ì–´ì•¼ í•œë‹¤.
```java
package example;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIf;

class ExternalCustomConditionDemo {

    @Test
    @EnabledIf("example.ExternalCondition#customCondition")
    void enabled() {
        // ...
    }

}

class ExternalCondition {

    static boolean customCondition() {
        return true;
    }

}
```
---
_ì¡°ê±´ ë©”ì†Œë“œê°€ static ì´ì–´ì•¼ í•˜ëŠ” ëª‡ê°€ì§€ ê²½ìš°ë“¤ì´ ìˆë‹¤:_
_@EnabledIf ë˜ëŠ” @DisabledIf ì–´ë…¸í…Œì´ì…˜ì´ class ìˆ˜ì¤€ì—ì„œ ì‚¬ìš©ë˜ëŠ” ê²½ìš°_
_@EnabledIf ë˜ëŠ” @DisabledIf ì–´ë…¸í…Œì´ì…˜ì´ @ParameterizedTest ë˜ëŠ” @TestTemplate ë©”ì†Œë“œì—ì„œ ì‚¬ìš©ë˜ëŠ” ê²½ìš°_
_ì¡°ê±´ ë©”ì†Œë“œê°€ ì™¸ë¶€ í´ë˜ìŠ¤ì— ìœ„ì¹˜í•˜ëŠ” ê²½ìš°_
_ê·¸ì™¸ì—ë„, ì¡°ê±´ ë©”ì†Œë“œëŠ” static ë©”ì†Œë“œ ë˜ëŠ” instance ë©”ì†Œë“œì¼ ìˆ˜ ìˆë‹¤._ 

_ì˜ˆë¡œ, java.awt.GraphicsEnvironmentëŠ” í˜„ì¬ í™˜ê²½ì´ ê·¸ë˜í”½ ë””ìŠ¤í”Œë ˆì´ë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ”ì§€ë¥¼ í™•ì¸í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” public static boolean isHeadless() ë©”ì†Œë“œë¥¼ ì œê³µí•œë‹¤.
ë”°ë¼ì„œ ì•„ë˜ ì˜ˆì œì™€ ê°™ì´ ê·¸ë˜í”½ ì§€ì›ì— ì˜ì¡´í•˜ëŠ” í…ŒìŠ¤íŠ¸ê°€ ê·¸ëŸ¬í•œ ì§€ì›ì´ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•œ ê²½ìš° ë¹„í™œì„±í™” í•  ìˆ˜ ìˆë‹¤._
```java
@DisabledIf(value = "java.awt.GraphicsEnvironment#isHeadless", disabledReason = "headless environment")
```

---


## 2.9. Tagging and Filtering
@Tag ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•´ì„œ í´ë˜ìŠ¤ë‚˜ ë©”ì†Œë“œì— tagë¥¼ ë‹¬ ìˆ˜ ìˆë‹¤.
tagëŠ” ì´í›„ í…ŒìŠ¤íŠ¸ ê²€ìƒ‰ ë° ì‹¤í–‰ì— ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤. tagì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ JUnit Platformì˜ Tag ë¶€ë¶„ ì°¸ê³ .

```java
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

@Tag("fast")
@Tag("model")
class TaggingDemo {

    @Test
    @Tag("taxes")
    void testingTaxCalculation() {
    }

}
```


## 2.10. Test Execution Order
ê¸°ë³¸ì ìœ¼ë¡œ, í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì™€ ë©”ì†Œë“œëŠ” ê²°ì •ì ì´ì§€ë§Œ ì˜ë„ì ìœ¼ë¡œ ëª…í™•í•˜ì§€ ì•Šì€ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì •ë ¬ëœë‹¤.
ì´ë ‡ê²Œ í•˜ë©´ í…ŒìŠ¤íŠ¸ ë„êµ¬ ëª¨ìŒì˜ í›„ì† ì‹¤í–‰ì—ì„œ ë™ì¼í•œ ìˆœì„œë¡œ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì™€ í…ŒìŠ¤íŠ¸ ë©”ì„œë“œë¥¼ ì‹¤í–‰í•˜ë¯€ë¡œ ë°˜ë³µ í•´ì„œ ë¹Œë“œê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

### 2.10.1. Method Order
ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ê°€ ì‹¤í–‰ ìˆœì„œì— ì˜í–¥ì„ ë°›ì§€ëŠ” ì•Šì§€ë§Œ, íŠ¹ì • í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œì˜ ì‹¤í–‰ ìˆœì„œë¥¼ ì œì–´í•˜ê³  ì‹¶ì€ ê²½ìš°ê°€ ìˆë‹¤.
ì˜ˆë¡œ, í†µí•©í…ŒìŠ¤íŠ¸ë‚˜ ê¸°ëŠ¥í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í• ë•Œ(íŠ¹ë³„íˆ @TestInstance(Lifecycle.PER_CLASS)ë¥¼ ì ìš©í•˜ëŠ” ê²½ìš°)ëŠ” í…ŒìŠ¤íŠ¸ ìˆœì„œê°€ ì¤‘ìš”í•œ ê²½ìš°ê°€ ìˆë‹¤.

í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ì˜ ì‹¤í–‰ ìˆœì„œë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ì„œëŠ” @TestMethodOrder ì–´ë…¸í…Œì´ì…˜ì— MethodOrderer êµ¬í˜„ì²´ë¥¼ ì§€ì •í•˜ë©´ ëœë‹¤.
ì‚¬ìš©ì ì§€ì • MethodOrdererë¥¼ êµ¬í˜„í•˜ê±°ë‚˜ ë‹¤ìŒ ë‚´ì¥ MethodOrderer êµ¬í˜„ ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
* MethodOrderer.DisplayName: í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ display ì´ë¦„ì˜ ì•ŒíŒŒë²³ ìˆœì„œë¡œ ì •ë ¬í•œë‹¤.
* MethodOrderer.MethodName: í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œ ì´ë¦„ê³¼ í˜•ì‹ ë§¤ê°œ ë³€ìˆ˜ ëª©ë¡ì— ë”°ë¼ í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ ì•ŒíŒŒë²³ ìˆœì„œë¡œ ì •ë ¬í•œë‹¤.
* MethodOrderer.OrderAnnotation: @Order ì–´ë…¸í…Œì´ì…˜ì— ì§€ì •ëœ ê°’ì— ë”°ë¼ í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ ì •ë ¬í•œë‹¤. 
* MethodOrderer.Random: í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ ë‚œìˆ˜ë¡œ ì •ë ¬í•˜ê³  ì‚¬ìš©ì ì •ì˜ ì‹œë“œë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤. 
* MethodOrderer.Alphanumeric: í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œ ì´ë¦„ê³¼ í˜•ì‹ ë§¤ê°œ ë³€ìˆ˜ ëª©ë¡ì— ë”°ë¼ í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ ì•ŒíŒŒë²³ ìˆœì„œë¡œ ì •ë ¬í•œë‹¤. MethodOrderer.MethodNameê°€ ìƒê¸°ë©´ì„œ deprecated ë˜ì—ˆë‹¤. 6.0 ë¶€í„°ëŠ” ì‚­ì œë  ê²ƒì´ë‹¤.

```java
public class MethodOrderDemo {

    @Nested
    @TestMethodOrder(MethodOrderer.DisplayName.class)
    class DisplayNameDemo {
//        ì‹¤í–‰ ìˆœì„œ
//        testA
//        testB
//        testD()
//        testE
        
        @Test
        @DisplayName("testA")
        void testA() {}

        @Test
        @DisplayName("testB")
        void testB() {}

        @Test
        @DisplayName("testE")
        void testC() {}

        @Test
        void testD() {}
    }

    @Nested
    @TestMethodOrder(MethodOrderer.MethodName.class)
    class MethodNameDemo {
//        ì‹¤í–‰ ìˆœì„œ
//        testA
//        testB
//        testE
//        testD()

        @Test
        @DisplayName("testA")
        void testA() {}

        @Test
        @DisplayName("testB")
        void testB() {}

        @Test
        @DisplayName("testE")
        void testC() {}

        @Test
        void testD() {}
    }


    @Nested
    @TestMethodOrder(MethodOrderer.OrderAnnotation.class)
    class OrderAnnotationDemo {
//        ì‹¤í–‰ìˆœì„œ
//        testB()
//        testD()
//        testC()
//        testA()
            
        @Test
        void testA() {}

        @Test
        @Order(0)
        void testB() {}

        @Test
        @Order(5)
        void testC() {}

        @Test
        @Order(1)
        void testD() {}
    }


    @Nested
    @TestMethodOrder(MethodOrderer.Random.class)
    class RandomDemo {
//        ì‹¤í–‰ìˆœì„œ ê°€ ë§¤ë²ˆ ë‹¤ë¦„
        @Test
        void testA() {}

        @Test
        void testB() {}

        @Test
        void testC() {}

        @Test
        void testD() {}
    }

}
```

#### Setting the Default Method Orderer
junit.jupiter.testmethod.order.default ì„¤ì • ê°’ì„ í†µí•´ì„œ ê¸°ë³¸ MethodOrdererë¥¼ ì§€ì •(ì „ì²´ ê²½ë¡œë¥¼ ëª¨ë‘ ì‘ì„±í•´ì•¼ í•œë‹¤)í•  ìˆ˜ ìˆë‹¤.
@TestMethodOrder ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì„¤ì •í• ë•Œì™€ ë§ˆì°¬ê°€ì§€ë¡œ MethodOrderer êµ¬í˜„ì²´ë¥¼ ì§€ì •í•´ì•¼í•œë‹¤.
@TestMethodOrder ê°€ ë³„ë„ë¡œ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš°ì— ì„¤ì •ëœë‹¤.

MethodOrderer.OrderAnnotation ë©”ì†Œë“œ ìˆœì„œë¥¼ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©í•˜ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì„¤ì •í•˜ë©´ ëœë‹¤.
(ì§ì ‘ êµ¬í˜„í•œ MethodOrdererì˜ êµ¬í˜„ì²´ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ì•„ë˜ì™€ ê°™ì´ ì „ì²´ ê²½ë¡œë¥¼ ì‘ì„±í•´ ì£¼ë©´ ëœë‹¤.)
```properties
junit.jupiter.testmethod.order.default = org.junit.jupiter.api.MethodOrderer$OrderAnnotation
```

### 2.10.2. Class Order
í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë“¤ì´ ì¼ë°˜ì ìœ¼ë¡œ ê·¸ ì‹¤í–‰ìˆœì„œì— ì˜í–¥ì„ ë°›ì§€ ì•ŠëŠ”ë‹¤ í•˜ë”ë¼ë„, íŠ¹ì • í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì˜ ì‹¤í–‰ ìˆœì„œë¥¼ ì œì–´í•˜ê³  ì‹¶ì€ ê²½ìš°ê°€ ìˆë‹¤.

í…ŒìŠ¤íŠ¸í´ë˜ìŠ¤ ì‚¬ì´ì— ì˜ë„ë˜ì§€ ì•Šì€ ì˜ì¡´ì„±ì´ ì—†ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•´ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë¥¼ ë¬´ì‘ìœ„ë¡œ ì‹¤í–‰í•˜ê³  ì‹¶ì€ ê²½ìš°ë„ ìˆê³ ,
ì•„ë˜ ì‹œë‚˜ë¦¬ì˜¤ ì²˜ëŸ¼ ë¹Œë“œíƒ€ì„ ìµœì í™”ë¥¼ ìœ„í•´ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì˜ ìˆœì„œë¥¼ ì •í•˜ê³  ì‹¶ì€ ê²½ìš°ë„ ìˆë‹¤.
* ì´ì „ì— ì‹¤íŒ¨í•œ í…ŒìŠ¤íŠ¸ì™€ ë¹ ë¥¸ í…ŒìŠ¤íŠ¸ë¥¼ ë¨¼ì € ì‹¤í–‰: "fail fast" ëª¨ë“œ
* ë³‘ë ¬ ì‹¤í–‰ì´ í™œì„±í™”ëœ ê²½ìš°, ë” ê¸´ í…ŒìŠ¤íŠ¸ë¥¼ ë¨¼ì € ì˜ˆì•½: "shortest test plan execution duration" ëª¨ë“œ
* ê·¸ì™¸ ê¸°íƒ€ ë“±ë“±

ì „ì²´ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì˜ ì‹¤í–‰ìˆœì„œë¥¼ ì„¤ì •í•˜ê¸° ìœ„í•´ì„œëŠ” junit.jupiter.testclass.order.default ì„¤ì • ê°’ì„ í†µí•´ì„œ ê¸°ë³¸ ClassOrdererë¥¼ ì§€ì •(ì§€ì •ë˜ëŠ” í´ë˜ìŠ¤ëŠ” ClassOrdererë¥¼ êµ¬í˜„í•´ì•¼í•˜ê³ , ì „ì²´ ê²½ë¡œë¥¼ ëª¨ë‘ ì‘ì„±í•´ì•¼ í•œë‹¤)í•  ìˆ˜ ìˆë‹¤.
ì•„ë˜ ë‚˜ì—´ëœ ê¸°ë³¸ìœ¼ë¡œ ì œê³µí•˜ëŠ” ClassOrderer êµ¬í˜„ì²´ë¥¼ ì‚¬ìš©í•´ë„ ë˜ê³ , ClassOrdererë¥¼ ì§ì ‘ êµ¬í˜„í•˜ì—¬ ì‚¬ìš©í•´ë„ ëœë‹¤.

* ClassOrderer.ClassName: ì „ì²´ ê²½ë¡œì˜ í´ë˜ìŠ¤ ì´ë¦„ ê¸°ì¤€ìœ¼ë¡œ ì•ŒíŒŒë²³ ìˆœì„œ ì •ë ¬ í•œë‹¤. 
* ClassOrderer.DisplayName: í´ë˜ìŠ¤ì˜ Display Name ê¸°ì¤€ìœ¼ë¡œ ì•ŒíŒŒë²³ ìˆœì„œ ì •ë ¬ í•œë‹¤.
* ClassOrderer.OrderAnnotation: @Order ì–´ë…¸í…Œì´ì…˜ì˜ ìˆ«ì ê°’(value) ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ í•œë‹¤.
* ClassOrderer.Random: í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë¥¼ ë‚œìˆ˜ë¡œ ì •ë ¬í•˜ê³  ì‚¬ìš©ì ì •ì˜ ì‹œë“œë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤.

```java

@TestClassOrder(ClassOrderer.ClassName.class)
public class MethodOrderDemo {

    @Nested
    class Aaa {
        @Test
        void testA() {}
    }

    @Nested
    class Ccc {
        @Test
        void testC() {}
    }


    @Nested
    class Bbb {
        @Test
        void testB() {}
    }
}
```

ê¸°ë³¸ ClassOrdererë¥¼ ì§€ì •í•˜ê³  ì‹¶ë‹¤ë©´ properties íŒŒì¼((e.g., in src/test/resources/junit-platform.properties))ì— ì•„ë˜ì™€ ê°™ì´ ì„¤ì •í•˜ë©´ ëœë‹¤.
```properties
junit.jupiter.testclass.order.default = org.junit.jupiter.api.ClassOrderer$OrderAnnotation

```
ì„¤ì •ëœ ClassOrdererëŠ” ëª¨ë“  ìµœìƒìœ„ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤(ì •ì  ì¤‘ì²© í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ í¬í•¨)ì™€ @Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì— ì ìš©ëœë‹¤.  
_ìµœìƒìœ„ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ëŠ” ì„œë¡œì—ê²Œ ìƒëŒ€ì ì¸ ìˆœì„œë¥¼ ë¶€ì—¬ë°›ëŠ”ë‹¤. ë°˜ë©´, @Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ëŠ” ë™ì¼í•œ í´ë˜ìŠ¤ì— í¬í•¨ëœ ë‹¤ë¥¸ @Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì— ìƒëŒ€ì ì¸ ìˆœì„œë¥¼ ë¶€ì—¬ë°›ëŠ”ë‹¤._

@Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì˜ ìˆœì„œë¥¼ ì§€ì—­ì ìœ¼ë¡œ(locally) ì§€ì •í•˜ê¸° ìœ„í•´ì„œëŠ”, @TestClassOrder ì–´ë…¸í…Œì´ì…˜ì„ ìƒìœ„(@Nested í…ŒìŠ¤íŠ¸í´ë˜ìŠ¤ë¥¼ í¬í•¨í•˜ëŠ) í´ë˜ìŠ¤ì— ì‚¬ìš©í•˜ë©´ ëœë‹¤.
ì´ë•Œ @TestClassOrder ì–´ë…¸í…Œì´ì…˜ì— ClassOrderer êµ¬í˜„ì²´ë¥¼ ì§€ì •í•´ ì¤€ë‹¤.
ì§€ì •ëœ ClassOrdererëŠ” @Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì™€ ê·¸ í•˜ìœ„ @Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì— ìˆœì°¨ì ìœ¼ë¡œ(recursively) ì ìš©ëœë‹¤.

ì§€ì—­ì ìœ¼ë¡œ(locally) ì§€ì •ëœ @TestClassOrder ì–´ë…¸í…Œì´ì…˜ì€ ìƒì†ë°›ì€ @TestClassOrder ì–´ë…¸í…Œì´ì…˜ ë˜ëŠ” junit.jupiter.testclass.order.default ì„¤ì • ê°’ìœ¼ë¡œ ì§€ì •ëœ ClassOrdererë¥¼ í•­ìƒ ì˜¤ë²„ë¼ì´ë“œí•œë‹¤.


## 2.11. Test Instance Lifecycle
ê°œë³„ í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰í•˜ê³  ë³€ê²½ê°€ëŠ¥í•œ í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ìƒíƒœë¡œ ì¸í•´ ì˜ˆìƒì¹˜ ëª»í•œ ë¶€ì‘ìš©ì´ ë°œìƒí•˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•´,
JUnitì€ ê° í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì˜ ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.
ì´ "per-method" í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ë¼ì´í”„ì‚¬ì´í´ì€ JUnit Jupiterì˜ ê¸°ë³¸ ë™ì‘ì´ë©°, ì´ì „ ë²„ì „ì˜ JUnitê³¼ ìœ ì‚¬í•˜ë‹¤.

_í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ëŠ” í…ŒìŠ¤íŠ¸ë©”ì†Œë“œê°€ ì¡°ê±´ì— ë”°ë¼ disabled(@Disabled, @DisabledOnOs, ë“±) ë˜ë”ë¼ë„ "per-method" í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ë¼ì´í”„ì‚¬ì´í´ëª¨ë“œê°€ ê°€ë™ì¤‘ ì´ë¼ë©´ ì—¬ì „íˆ ì¡´ì¬ í•œë‹¤._

ë§Œì•½ JUnit Jupiter ê°€ ëª¨ë“  í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë¥¼ ë™ì¼í•œ í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì‹¤í–‰í•˜ë„ë¡ í•˜ê³  ì‹¶ë‹¤ë©´, í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì— @TestInstance(Lifecycle.PER_CLASS) ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ë©´ ëœë‹¤.
ì´ ëª¨ë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°, ìƒˆë¡œìš´ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ëŠ” í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë‹¹ í•œë²ˆë§Œ ìƒì„±ëœë‹¤.
ë”°ë¼ì„œ, í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œê°€ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì— ì €ì¥ëœ ìƒíƒœ ì˜ì¡´í•˜ê³  ìˆë‹¤ë©´, @BeforeEach ë˜ëŠ” @AfterEach ë©”ì†Œë“œì—ì„œ í•´ë‹¹ ìƒíƒœë¥¼ ì¬ì„¤ì •í•´ì•¼ í•œë‹¤.

"per-class" ëª¨ë“œëŠ” "per-method" ëª¨ë“œë³´ë‹¤ ëª‡ê°€ì§€ ì¶”ê°€ì ì¸ ì´ì ì´ ìˆë‹¤. 
íŠ¹ë³„íˆ, "per-class" ëª¨ë“œì—ì„œ @BeforeAll, @AfterAll ì–´ë…¸í…Œì´ì…˜ì€ ì¸í„°í˜ì´ìŠ¤ì˜ default ë©”ì†Œë“œ ë¿ ì•„ë‹ˆë¼ non-static ë©”ì†Œë“œì—ë„ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤.
@BeforeAll, @AfterAll ì–´ë…¸í…Œì´ì…˜ì€ @Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

_Java 16 ë²„ì „ ì´í›„ë¡œ, @BeforeAll, @AfterAll ì–´ë…¸í…Œì´ì…˜ì€ @Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì—ì„œ staticìœ¼ë¡œ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤._

ì½”í‹€ë¦°ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ëª¨ë“œë¥¼ ì‘ì„±í•˜ê³  ìˆë‹¤ë©´, 
"per-class" í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ë¼ì´í”„ ì‚¬ì´í´ ëª¨ë“œë¡œ ë³€í™˜í•˜ì—¬ non-static @BeforeAll, @AfterAll ë¼ì´í”„ì‚¬ì´í´ ë©”ì†Œë“œ ë° @MethodSource íŒ©í† ë¦¬ ë©”ì†Œë“œë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ë” ì‰½ë‹¤. 

### 2.11.1. Changing the Default Test Instance Lifecycle
í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë‚˜ í…ŒìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤ì— @TestInstance ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ì§€ ì•Šì€ê²½ìš°, JUnit JupiterëŠ” ê¸°ë³¸ ë¼ì´í”„ì‚¬ì´í´ ëª¨ë“œë¥¼ ì‚¬ìš©í•œë‹¤.
ê¸°ë³¸ ëª¨ë“œëŠ” PER_METHOD ì´ë‹¤. í•˜ì§€ë§Œ, ì „ì²´ í…ŒìŠ¤íŠ¸ ê³„íšì˜ ê¸°ë³¸ ì‹¤í–‰ì„ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.
í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ì˜ ê¸°ë³¸ ë¼ì´í”„ì‚¬ì´í´ ëª¨ë“œë¥¼ ë³€ê²½í•˜ê¸° ìœ„í•´ì„œëŠ” junit.jupiter.testinstance.lifecycle.default ì„¤ì •ê°’ì„ TestInstance.Lifecycle ì— ì •ì˜ ë˜ì–´ ìˆëŠ” enum ìœ¼ë¡œ ì§€ì •í•˜ë©´ ëœë‹¤. 
í•´ë‹¹ ì„¤ì • ê°’ì€ JVM ì‹œìŠ¤í…œ í”„ë¡œí¼í‹°ë‚˜, LauncherDiscoveryRequest ì— ì „ë‹¬ë˜ëŠ” ì„¤ì • íŒŒë¼ë¯¸í„°, ë˜ëŠ” JUnit Platform ì„¤ì • íŒŒì¼ì— ì§€ì •í•  ìˆ˜ ìˆë‹¤.

ì•„ë˜ ì˜ˆ ì²˜ëŸ¼ JVM ì‹œìŠ¤í…œ ì†ì„±ê°’ì„ ì´ìš©í•´ì„œ í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ì˜ ë¼ì´í”„ ì‚¬ì´í´ ëª¨ë“œë¥¼ Lifecycle.PER_CLASS ë¡œ ì„¤ì • í•  ìˆ˜ ìˆë‹¤.
```shell
-Djunit.jupiter.testinstance.lifecycle.default=per_class
```

JUnit í”Œë«í¼ ì„¤ì • íŒŒì¼ì„ í†µí•œ í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ì˜ ë¼ì´í”„ì‚¬ì´í´ ëª¨ë“œ ì„¤ì •ì€ ì¡°ê¸ˆë” ê°•ë ¥í•œ ë°©ë²•ì´ë‹¤. ì™œëƒí•˜ë©´ ì„¤ì • íŒŒì¼ì€ ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œìœ¼ë¡œ ê´€ë¦¬ ê°€ëŠ¥í•´ì„œ IDEë‚˜ ë¹Œë“œ ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

JUnit Platform ì„¤ì • íŒŒì¼ë¡œ í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ì˜ ê¸°ë³¸ ë¼ì´í”„ ì‚¬ì´í´ ëª¨ë“œë¥¼ Lifecycle.PER_CLASSë¡œ ì„¤ì •í•˜ê¸° ìœ„í•´ì„œëŠ” "junit-platform.properties"íŒŒì¼ì„ í´ë˜ìŠ¤ íŒ¨ìŠ¤ì˜ ìµœ ìƒë‹¨ (e.g., src/test/resources)ì— ìƒì„±í•˜ê³  ì•„ë˜ ë‚´ìš©ì„ ì¶”ê°€í•œë‹¤.  
```shell
junit.jupiter.testinstance.lifecycle.default = per_class
```

_í…ŒìŠ¤íŠ¸ ì¸ìŠ¤í„´ìŠ¤ì˜ ê¸°ë³¸ ë¼ì´í”„ ì‚¬ì´í´ ëª¨ë“œ ë³€ê²½ì´ ì¼ê´€ë˜ê²Œ ì ìš©ë˜ì§€ ì•ŠëŠ” ê²½ìš°, ì˜ˆì¸¡ í•  ìˆ˜ ì—†ëŠ” ê²°ê³¼ì™€ ë¹Œë“œê°€ ê¹¨ì§€ëŠ” ë¬¸ì œë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤.
ì˜ˆë¡œ, ë¹Œë“œ ì„¤ì •ì€ "per-class" ë¼ì´í”„ ì‚¬ì´í´ ëª¨ë“œë¥¼ ê¸°ë³¸ìœ¼ë¡œ êµ¬ì„±í•˜ì§€ë§Œ IDEì—ì„œ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•  ë•ŒëŠ” "per-method" ë¼ì´í”„ ì‚¬ì´í´ ëª¨ë“œë¥¼ ì‚¬ìš©í•œë‹¤ë©´,
ë¹Œë“œ ì„œë²„ì—ì„œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ë¥¼ ë””ë²„ê¹…í•˜ëŠ” ê²ƒì´ ì–´ë ¤ìš¸ ìˆ˜ ìˆë‹¤.
ë”°ë¼ì„œ, JVM ì‹œìŠ¤í…œ ë³€ìˆ˜ ë³´ë‹¤ëŠ” JUnit í”Œë«í¼ ì„¤ì • íŒŒì¼ë¡œ ê¸°ë³¸ ì„¤ì •ì„ ë³€ê²½í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤._



## 2.12. Nested Tests
@Nested í…ŒìŠ¤íŠ¸ëŠ” í…ŒìŠ¤íŠ¸ ì‘ì„±ìë“¤ì´ ì—¬ëŸ¬ í…ŒìŠ¤íŠ¸ ê·¸ë£¹ ê°„ì˜ ê´€ê³„ë¥¼ í‘œí˜„í•˜ëŠ” ë” ë§ì€ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.
nested í…ŒìŠ¤íŠ¸ëŠ” ìë°”ì˜ ì¤‘ì²© í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê³  í…ŒìŠ¤íŠ¸ êµ¬ì¡°ì— ëŒ€í•œ ê³„ì¸µì ì¸ ìƒê°ì„ ìš©ì´í•˜ê²Œ í•œë‹¤.

_Nested test suite for testing a stack_
```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.EmptyStackException;
import java.util.Stack;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

@DisplayName("A stack")
class TestingAStackDemo {

    Stack<Object> stack;

    @Test
    @DisplayName("is instantiated with new Stack()")
    void isInstantiatedWithNew() {
        new Stack<>();
    }

    @Nested
    @DisplayName("when new")
    class WhenNew {

        @BeforeEach
        void createNewStack() {
            stack = new Stack<>();
        }

        @Test
        @DisplayName("is empty")
        void isEmpty() {
            assertTrue(stack.isEmpty());
        }

        @Test
        @DisplayName("throws EmptyStackException when popped")
        void throwsExceptionWhenPopped() {
            assertThrows(EmptyStackException.class, stack::pop);
        }

        @Test
        @DisplayName("throws EmptyStackException when peeked")
        void throwsExceptionWhenPeeked() {
            assertThrows(EmptyStackException.class, stack::peek);
        }

        @Nested
        @DisplayName("after pushing an element")
        class AfterPushing {

            String anElement = "an element";

            @BeforeEach
            void pushAnElement() {
                stack.push(anElement);
            }

            @Test
            @DisplayName("it is no longer empty")
            void isNotEmpty() {
                assertFalse(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when popped and is empty")
            void returnElementWhenPopped() {
                assertEquals(anElement, stack.pop());
                assertTrue(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when peeked but remains not empty")
            void returnElementWhenPeeked() {
                assertEquals(anElement, stack.peek());
                assertFalse(stack.isEmpty());
            }
        }
    }
}
```
ì˜ˆì œë¥¼ ì‹¤í–‰í•˜ë©´ IDEì—ì„œëŠ” í…ŒìŠ¤íŠ¸ ì‹¤í–‰ íŠ¸ë¦¬ê°€ í‘œì‹œëœë‹¤.  
ì´ ì˜ˆì œì—ì„œ, ì™¸ë¶€ í…ŒìŠ¤íŠ¸ì˜ ì „ì œ ì¡°ê±´ì€ ì…‹ì—…ì„ ìœ„í•œ ìš©ë„ë¡œ ê³„ì¸µì  ë¼ì´í”„ì‚¬ì´í´ ë©”ì†Œë“œë¥¼ í†µí•´ ë‚´ë¶€ í…ŒìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©ë˜ëŠ”ë°, 
createNewStack() í•¨ìˆ˜ëŠ” @BeforeEach ë¼ì´í”„ì‚¬ì´í´ ë©”ì†Œë“œë¡œ ì •ì˜ë˜ì—ˆê³ , ê·¸ê²ƒì´ ì •ì˜ëœ í´ë˜ìŠ¤ì™€ ê·¸ í•˜ìœ„ì˜ ëª¨ë“  ë ˆë²¨ì—ì„œ ì‚¬ìš©ëœë‹¤.

ì™¸ë¶€ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì˜ ì…‹ì—… ì½”ë“œëŠ” ë‚´ë¶€ í…ŒìŠ¤íŠ¸ê°€ ì‹¤í–‰ë˜ê¸° ì „ì— ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ì—, ëª¨ë“  í…ŒìŠ¤íŠ¸ë¥¼ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤. 
ì™¸ë¶€í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•˜ì§€ ì•Šê³  ë‚´ë¶€ í…ŒìŠ¤íŠ¸ë§Œ ì‹¤í–‰í–ˆë‹¤ í•˜ë”ë¼ë„ ì™¸ë¶€ì˜ ì…‹ì—… ì½”ë“œëŠ” í•­ìƒ ì‹¤í–‰ëœë‹¤.


_non-static nested í´ë˜ìŠ¤ë§Œ @Nested í…ŒìŠ¤íŠ¸ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤. static nested í´ë˜ìŠ¤ëŠ” @Nested í…ŒìŠ¤íŠ¸ë¡œ ì‚¬ìš©ë  ìˆ˜ ì—†ë‹¤.
ì¤‘ì²©ì€ ì„ì˜ë¡œ ê¹Šê²Œ í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŸ¬í•œ ë‚´ë¶€ í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ ì˜ˆì™¸ë¥¼ ì œì™¸í•˜ê³  ì „ì²´ ë¼ì´í”„ì‚¬ì´í´ ì§€ì›ì„ ë°›ëŠ”ë‹¤. (@BeforeAll ê³¼ @AfterAll ë©”ì†Œë“œëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤.)
ì´ìœ ëŠ” Java 16 ì´ì „ì—ëŠ” ë‚´ë¶€ í´ë˜ìŠ¤ì—ì„œ static ë©¤ë²„ë¥¼ í—ˆìš©í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì´ë‹¤.
ê·¸ëŸ¬ë‚˜, ì´ ì œí•œì€ @Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì— @TestInstance(Lifecycle.PER_CLASS) ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ì—¬ ìš°íšŒí•  ìˆ˜ ìˆë‹¤.
ë§Œì•½ Java 16ì´ìƒì˜ ë²„ì „ì„ ì‚¬ìš©í•œë‹¤ë©´, @BeforeAll ê³¼ @AfterAll ë©”ì†Œë“œëŠ” @Nested í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ì—ì„œ staticìœ¼ë¡œ ì„ ì–¸í•  ìˆ˜ ìˆê³ , ì´ ì œí•œì€ ë”ì´ìƒ ì ìš©ë˜ì§€ ì•ŠëŠ”ë‹¤._

## 2.13. Dependency Injection for Constructors and Methods
In all prior JUnit versions, test constructors or methods were not allowed to have parameters (at least not with the standard Runner implementations). As one of the major changes in JUnit Jupiter, both test constructors and methods are now permitted to have parameters. This allows for greater flexibility and enables Dependency Injection for constructors and methods.

ParameterResolver defines the API for test extensions that wish to dynamically resolve parameters at runtime. If a test class constructor, a test method, or a lifecycle method (see Definitions) accepts a parameter, the parameter must be resolved at runtime by a registered ParameterResolver.

There are currently three built-in resolvers that are registered automatically.

* TestInfoParameterResolver: if a constructor or method parameter is of type TestInfo, the TestInfoParameterResolver will supply an instance of TestInfo corresponding to the current container or test as the value for the parameter. The TestInfo can then be used to retrieve information about the current container or test such as the display name, the test class, the test method, and associated tags. The display name is either a technical name, such as the name of the test class or test method, or a custom name configured via @DisplayName.
TestInfo acts as a drop-in replacement for the TestName rule from JUnit 4. The following demonstrates how to have TestInfo injected into a test constructor, @BeforeEach method, and @Test method.
```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

@DisplayName("TestInfo Demo")
class TestInfoDemo {

    TestInfoDemo(TestInfo testInfo) {
        assertEquals("TestInfo Demo", testInfo.getDisplayName());
    }

    @BeforeEach
    void init(TestInfo testInfo) {
        String displayName = testInfo.getDisplayName();
        assertTrue(displayName.equals("TEST 1") || displayName.equals("test2()"));
    }

    @Test
    @DisplayName("TEST 1")
    @Tag("my-tag")
    void test1(TestInfo testInfo) {
        assertEquals("TEST 1", testInfo.getDisplayName());
        assertTrue(testInfo.getTags().contains("my-tag"));
    }

    @Test
    void test2() {
    }

}
```
* RepetitionExtension: if a method parameter in a @RepeatedTest, @BeforeEach, or @AfterEach method is of type RepetitionInfo, the RepetitionExtension will supply an instance of RepetitionInfo. RepetitionInfo can then be used to retrieve information about the current repetition, the total number of repetitions, the number of repetitions that have failed, and the failure threshold for the corresponding @RepeatedTest. Note, however, that RepetitionExtension is not registered outside the context of a @RepeatedTest. See Repeated Test Examples.
* TestReporterParameterResolver: if a constructor or method parameter is of type TestReporter, the TestReporterParameterResolver will supply an instance of TestReporter. The TestReporter can be used to publish additional data about the current test run. The data can be consumed via the reportingEntryPublished() method in a TestExecutionListener, allowing it to be viewed in IDEs or included in reports.
In JUnit Jupiter you should use TestReporter where you used to print information to stdout or stderr in JUnit 4. Using @RunWith(JUnitPlatform.class) will output all reported entries to stdout. In addition, some IDEs print report entries to stdout or display them in the user interface for test results.
```java
class TestReporterDemo {

    @Test
    void reportSingleValue(TestReporter testReporter) {
        testReporter.publishEntry("a status message");
    }

    @Test
    void reportKeyValuePair(TestReporter testReporter) {
        testReporter.publishEntry("a key", "a value");
    }

    @Test
    void reportMultipleKeyValuePairs(TestReporter testReporter) {
        Map<String, String> values = new HashMap<>();
        values.put("user name", "dk38");
        values.put("award year", "1974");

        testReporter.publishEntry(values);
    }

}
```
_Other parameter resolvers must be explicitly enabled by registering appropriate extensions via @ExtendWith._
Check out the RandomParametersExtension for an example of a custom ParameterResolver. While not intended to be production-ready, it demonstrates the simplicity and expressiveness of both the extension model and the parameter resolution process. MyRandomParametersTest demonstrates how to inject random values into @Test methods.

```java
@ExtendWith(RandomParametersExtension.class)
class MyRandomParametersTest {

    @Test
    void injectsInteger(@Random int i, @Random int j) {
        assertNotEquals(i, j);
    }

    @Test
    void injectsDouble(@Random double d) {
        assertEquals(0.0, d, 1.0);
    }

}
```
For real-world use cases, check out the source code for the MockitoExtension and the SpringExtension.

When the type of the parameter to inject is the only condition for your ParameterResolver, you can use the generic TypeBasedParameterResolver base class. The supportsParameters method is implemented behind the scenes and supports parameterized types.