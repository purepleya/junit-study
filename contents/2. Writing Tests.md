## 2.2 Definitions
### Lifecycle Method
@BeforeAll, @AfterAll, @BeforeEach, @AfterEach

### Test Class
Test class 는 abstract 여서는 안되며, 단 하나의 생성자(constructor)를 가져야 한다.
1. 최상위 class
2. static member class 
3. @Nested 로 정의되고 테스트 메소드를 하나이상 가지고 있는 class


## 2.3 Test Classes and Methods
test 함수와 lifecycle 함수는 현재 class 내부에 선언되거나, 부모 클래스나 interface 로 부터 상속 받는다.
덧 붙여, 테스트 함수와 라이프 사이클 함수는 추상 함수로 선언 될 수 없으면 return value 를 가질 수 없다. 

---
_Class 와 method의 가시성
test class, test 함수, lifecycle 함수는 public 일 필요는 없으나 private로 선언되서는 안된다.<br/>
일반적으로, 다른 package에서 test class나 test 함수, lifecycle 함수 를 사용하는 경우를 제외하고 public 수정자를 생략하는것을 추천한다._
---
일반적인 test 함수와 lifecycle 함수의 사용 방법은 아래와 같다.
```java
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {
    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @Test
    void abortedTest() {
        assumeTrue("abc".contains("Z"));
        fail("test should have been aborted");
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }
}
```


## 2.4 Display Names
test class 와 test 함수는 @DisplayName 어노테이션을 통해 표시되는 테스트 명(display name)을 변경 할 수 있다. 표시 할 수 있는 테스트 명은 공백, 특수문자, 이모지 까지 가능하고, 변경한 테스트 명은 테스트 보고서나, 테스트 실행기, IDE 에서 표시 된다.

```java
@DisplayName("A special test case")
class DisplayNameDemo {

    @Test
    @DisplayName("Custom test name containing spaces")
    void testWithDisplayNameContainingSpaces() {
    }

    @Test
    @DisplayName("╯°□°）╯")
    void testWithDisplayNameContainingSpecialCharacters() {
    }

    @Test
    @DisplayName("😱")
    void testWithDisplayNameContainingEmoji() {
    }

}
```

### 2.4.1. Display Name Generators
JUnit Jupiter는 @DisplayNameGeneration 어노테이션을 이용하는 custom display name 생성기를 지원한다.  
@DisplayName의 값이 @DisplayNameGeneration를 통해 생성된 값 보다 항상 우선한다.

DisplayNameGenerator를 구현함 으로서 생성기를 만 들 수 있다.  
아래는 Jupiter에서 기본을 제공하는 생성기 들이다.

|DisplayNameGenerator| Behavior                                                 |
|---|----------------------------------------------------------|
|Standard| Junit Jupiter 5.0이 출시 된 이후 사용되어오고 있는 기본 display name 생성기 |
|Simple| 파라미터가 없는 함수의 괄호를 삭제 하는 생성기                               |
|ReplaceUnderscores| 밑줄(underscore)을 공백(space)로 변환하는 생성기                      |
|IndicativeSentences| test와 이를 포함하는 class 명을 합쳐서 완성된 문장을 생성하는 생성기              |

@IndicativeSentencesGeneration 어노테이션을 이용하면, IndicativeSentences 기능에 separator(기본은 ", ")와 기본 display name 생성기를 별도로 정의 할 수 있다.
```java
class DisplayNameGeneratorDemo {

    @Nested
    @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_not_supported {

        @Test
        void if_it_is_zero() {}
//        if it is zero

        @DisplayName("A negative value for year is not supported by the leap year computation.")
        @ParameterizedTest(name = "For example, year {0} is not supported.")
        @ValueSource(ints = { -1, -4 })
        void if_it_is_negative(int year) {}
//        A negative value for year is not supported by the leap year computation.
//            For example, year -1 is not supported.
//            For example, year -4 is not supported.
    }

    @Nested
    @IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
    class A_year_is_a_leap_year {

        @Test
        void if_it_is_divisible_by_4_but_not_by_100() {
        }
//        A year is a leap year -> if it is divisible by 4 but not by 100

        @ParameterizedTest(name = "Year {0} is a leap year.")
        @ValueSource(ints = { 2016, 2020, 2048 })
        void if_it_is_one_of_the_following_years(int year) {
        }
//        A year is a leap year -> if it is one of the following years
//            Year 2016 is a leap year
//            Year 2020 is a leap year
//            Year 2048 is a leap year        
    }

}
```

### 2.4.2. Setting the Default Display Name Generator
junit 속성 파일 (src/test/resources/junit-platform.properties) 에 "junit.jupiter.displayname.generator.default"값을 이용하여 기본 display name 생성기를 설정 할 수 있다.  
@DisplayNameGeneration 어노테이션과 마찬가지로 설정 값 보다 @DisplayName 어노테이션의 값이 더 우선하며, 사용자가 DisplayNameGenerator를 구현하여 생성한 사용자 정의 display name 생성기 클래스도 적용 가능하다.  
```properties
junit.jupiter.displayname.generator.default = org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
```

## 2.5. Assertions
JUnit Jupiter 에서는 Junit 4에서 사용하던 assertion 함수에 Java 8 lambda 사용에 적합한 함수들이 추가 되었다. 
Junit Jupiter의 모든 assertion은 org.junit.jupiter.api.Assertions 클래스에 static 함수로 정의 되어 있다.

```java
import static java.time.Duration.ofMillis;
import static java.time.Duration.ofMinutes;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.CountDownLatch;

import example.domain.Person;
import example.util.Calculator;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

class AssertionsDemo {

    private final Calculator calculator = new Calculator();

    private final Person person = new Person("Jane", "Doe");

    @Test
    void standardAssertions() {
        assertEquals(2, calculator.add(1, 1));        
//        마지막 파라미터로 실패 메시지를 전달 할 수 있다.
        assertEquals(4, calculator.multiply(2, 2), "The optional failure message is now the last parameter");
//        supplier를 이용하여 실패 메시지를 지연 할 수 있다.
        assertTrue('a' < 'b', () -> "Assertion messages can be lazily evaluated -- " + "to avoid constructing complex messages unnecessarily.");
    }

    @Test
    void groupedAssertions() {
//        assertAll 을 이용해서 복수건을 한번에 검증 할 수 있다.
        assertAll("person",
            () -> assertEquals("Jane", person.getFirstName()),
            () -> assertEquals("Doe", person.getLastName())
        );
    }

    @Test
    void dependentAssertions() {
        assertAll("properties",
            () -> {
//                코드블록 안에 assertion 코드를 작성한 경우, assertion이 실패하면 이후 코드는 실행되지 않는다. 모든 assertion 이 성공한 이후 코드가 실행된다.
                String firstName = person.getFirstName();
                assertNotNull(firstName);
                assertEquals("Jane", firstName);
                
                assertAll("first name",
                    () -> assertTrue(firstName.startsWith("J")),
                    () -> assertTrue(firstName.endsWith("e"))
                );
            },
            () -> {
//                assertAll 의 각 개별 assertion은 독립적으로 실행되기 때문에, assertion이 실패하더라도 이후 assertion은 실행된다.
//                아래 코드는 위의 firstName assertion이 실패하더라도 실행된다.
                String lastName = person.getLastName();
                assertNotNull(lastName);

                assertAll("last name",
                    () -> assertTrue(lastName.startsWith("D")),
                    () -> assertTrue(lastName.endsWith("e"))
                );
            }
        );
    }

    @Test
    void exceptionTesting() {
//        발생이 예상되는 Exception 을 assertThrows 의 첫번째 파라미터로 전달하고, 두번째 파라미터로 예외가 발생하는 코드를 람다로 전달하여
//        예상한 Exception 이 발생하는지 확인한다.
        Exception exception = assertThrows(ArithmeticException.class, () ->
            calculator.divide(1, 0));
        assertEquals("/ by zero", exception.getMessage());
    }

    @Test
    void timeoutNotExceeded() {
//        코드실행 시간이 2초를 넘기면 assertion 실패한다.
        assertTimeout(Duration.ofSeconds(2), () -> {
            Thread.sleep(1000);
        });
    }
    
    @Test
    void timeoutNotExceededWithResult() {
//        코드가 실행되는 동안에 결과값을 리턴하는 경우, 리턴된 결과값을 assertion 할 수 있다.
//        Timeout 이 발생하면 assertion 실패하고 테스트 종료되며, Timeout 이 발생하지 않으면 리턴된 결과값을 assertion 한다.
        String actualResult = assertTimeout(ofMinutes(2), () -> {
            return "a result";
        });
        assertEquals("a result", actualResult);
    }

    @Test
    void timeoutNotExceededWithMethod() {
//        method 참조를 이용하여 assertion 할 수 있다.
        String actualGreeting = assertTimeout(ofMinutes(2), AssertionsDemo::greeting);
        assertEquals("Hello, World!", actualGreeting);
    }
    
    @Test
    void timeoutExceededWithPreemptiveTermination() {
//        timeoutExceededWithPreemptiveTermination 함수를 이용해서 assertTimeout 과 같은 테스트를 진행 할 수 있다.
//        timeoutExceededWithPreemptiveTermination가 assertTimeout 과 다른 점은 아래 설명 참고
        assertTimeoutPreemptively(ofMillis(10), () -> {
            new CountDownLatch(1).await();
        });
    }

    private static String greeting() {
        return "Hello, World!";
    }

}
```

---
_assertTimeoutPreemptively() 함수를 이용한 선제적 타임아웃  
Assertions 클래스에 있는 다양한 assertTimeoutPreemptively()는 Executable 타입이나 Supplier 타입을 호출하는 코드와 분리된 다른 스레드에서 실행한다. Executable이나 Supplier의 코드가 java.lang.ThreadLocal storage를 이용하는 경우 부작용을 일으킬 수 있다.  
Spring Framework 에서 지원하는 트랜잭션 테스트가 대표적인 예 이다.  
특별히 스프링 테스트는  테스트 함수가 실행 되기 전에 TreadLocal을 이용해 트랜잭션 상태를 현재 스레드에 바인딩 한다.  
결과적으로, assertTimeoutPreemptively()함수에 제공된 Excutable이나 Sullpier가 트랜잭션에 포함되는 스프링 관리 콤포넌트를 실행한다면, 콤포넌트가 수행하는 어떤 행동들도 test에서 관리되는 트랜잭션과 함께 롤백되지 않는다.
이와 반대로, test 관리 트랜잭션이 롤백된다 하더라도, 해당 행동들은 db와 같은 persistent sotre에 커밋 된다.  
ThreadLocal storage를 이용하는 다른 프레임웍들도 비슷한 부작용을 일으킬 수 있다._
---

### 2.5.1. Kotlin Assertion Support
JUnit Jupiter 는 Kotlin에 적합한 assertion 함수도 일부 지원하고, 이는 JUnit Jupiter의 org.junit.jupiter.api 패키지의 최 상위 함수로 되어 있다.  
Kotlin 관련 내용은 일단 패스~~~

```kotlin
import example.domain.Person
import example.util.Calculator
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertAll
import org.junit.jupiter.api.assertDoesNotThrow
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.assertTimeout
import org.junit.jupiter.api.assertTimeoutPreemptively
import java.time.Duration

class KotlinAssertionsDemo {

    private val person = Person("Jane", "Doe")
    private val people = setOf(person, Person("John", "Doe"))

    @Test
    fun `exception absence testing`() {
        val calculator = Calculator()
        val result = assertDoesNotThrow("Should not throw an exception") {
            calculator.divide(0, 1)
        }
        assertEquals(0, result)
    }

    @Test
    fun `expected exception testing`() {
        val calculator = Calculator()
        val exception = assertThrows<ArithmeticException> ("Should throw an exception") {
            calculator.divide(1, 0)
        }
        assertEquals("/ by zero", exception.message)
    }

    @Test
    fun `grouped assertions`() {
        assertAll(
            "Person properties",
            { assertEquals("Jane", person.firstName) },
            { assertEquals("Doe", person.lastName) }
        )
    }

    @Test
    fun `grouped assertions from a stream`() {
        assertAll(
            "People with first name starting with J",
            people
                .stream()
                .map {
                    // This mapping returns Stream<() -> Unit>
                    { assertTrue(it.firstName.startsWith("J")) }
                }
        )
    }

    @Test
    fun `grouped assertions from a collection`() {
        assertAll(
            "People with last name of Doe",
            people.map { { assertEquals("Doe", it.lastName) } }
        )
    }

    @Test
    fun `timeout not exceeded testing`() {
        val fibonacciCalculator = FibonacciCalculator()
        val result = assertTimeout(Duration.ofMillis(1000)) {
            fibonacciCalculator.fib(14)
        }
        assertEquals(377, result)
    }

    @Test
    fun `timeout exceeded with preemptive termination`() {
        // The following assertion fails with an error message similar to:
        // execution timed out after 10 ms
        assertTimeoutPreemptively(Duration.ofMillis(10)) {
            // Simulate task that takes more than 10 ms.
            Thread.sleep(100)
        }
    }
}
```

### 2.5.2. Third-party Assertion Libraries
JUnit Jupiter에 의해 제공되는 assertion 기능들이 많은 테스트 시나리오에 적합하다 하더라도, 때때로 matcher와 같은 추가 기능들이 필요한 경우가 있다.
그런 경우, JUnit 팀은 AssertJ, Hamcrest, Truth 등의 서드파티 assertion 라이브러리를 사용할 것을 권장한다.

예로, matcher와 fluent API의 조합은 assertion을 더 자세하고 읽기 쉽게 만들 수 있다. 그러나 Junit 4에서 지원하고 Hamcrest Matcher에서 채택된 assertThat() 함수는 JUnit Jupiter에서는 지원하지 않는다.
대신, 개발자들은 서드파티 assertion 라이브러리에서 제공하는 matcher를 사용할 것을 권장한다. 

아래 예제는 JUnit Jupiter 테스트에서 Hamcrest의 assertThat() 함수를 사용하는 방법을 보여준다. Hamcrest 라이브러리가 classpath에 추가되어 있는한, assertThat(), is(), equalTo()와 같은 함수들을 static import 할 수 있고, 아래의 assertWithHamcrestMatcher() 함수처럼 테스트에서 사용할 수 있다.

```java
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class HamcrestAssertionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void assertWithHamcrestMatcher() {
        assertThat(calculator.subtract(4, 1), is(equalTo(3)));
    }

}
```
물론, JUnit 4 프로그래밍 모델을 기반으로 한 레거시 테스트는 org.junit.Assert#assertThat을 계속 사용할 수 있다.


## 2.6. Assumptions
JUnit Jupiter 에는 JUnit 4에서 제공하는 assumption 메소드의 하위 집합이 포함되어 있으며, Java 8 람다 표현식과 메소드 참조를 사용하는 데 적합한 몇 가지 메소드가 추가되었다. 
모든 JUnit Jupiter assumption 메소드는 org.junit.jupiter.api.Assumptions 클래스에 static 으로 정의 되어 있다.

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.junit.jupiter.api.Assumptions.assumingThat;

import example.util.Calculator;

import org.junit.jupiter.api.Test;

class AssumptionsDemo {

    private final Calculator calculator = new Calculator();

    @Test
    void testOnlyOnCiServer() {
        assumeTrue("CI".equals(System.getenv("ENV")));
    }

    @Test
    void testOnlyOnDeveloperWorkstation() {
//        테스트가 실패하면, 테스트는 실패로 표시되지 않고, 무시된다.
//        테스트가 실패할 경우 "Assumption failed: Aborting test: not on developer workstation" 메시지가 표시된다.
        assumeTrue("DEV".equals(System.getenv("ENV")),
                () -> "Aborting test: not on developer workstation");
    }

    @Test
    void testInAllEnvironments() {
//        첫번째 파라미터가 true 일 경우, 두번째 파라미터로 전달된 람다 표현식이 실행된다.
//        천번째 파라미터가 false 일 경우, 두번째 파라미터로 전달된 람다 표현식은 무시 된다.
        assumingThat("CI".equals(System.getenv("ENV")),
                () -> {
                    assertEquals(2, calculator.divide(4, 2));
                });

        // System.getenv("ENV") 가 CI 이던 아니던, (중간에 assertion 이 실패하지 않는 이상) 무조건 실행 된다.
        assertEquals(42, calculator.multiply(6, 7));
    }

}
```

---
_JUnit Jupiter 5.4 이후로, JUnit 4의 org.junit.Assume 클래스의 메소드를 assumption으로 사용할 수 있다. 특히, JUnit Jupiter는 JUnit 4의 AssumptionViolatedException을 지원하여 테스트가 실패로 표시되는 대신 테스트가 중단되어야 함을 나타낸다._

---


## 2.7. Disabling Tests
테스트 클래스나 개별 테스트 함수를 비 활성화 시키는 방법
1. @Disabled 어노테이션
2. Conditional Test Execution 에서 설명한 어노테이션 사용
3. 사용자 정의 ExecutionCondition을 사용

@Disabled 예제
```java
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

public class DisabledDemo {
    @Disabled("Disabled until bug #42 has been resolved")
    @Test
    void testWillBeSkipped() {
    }

    @Test
    void testWillBeExecuted() {
    }

    @Disabled
    @Nested
    class DisabledTestClass {
        @Test
        void testWillBeSkipped() {
        }
    }

    @Nested
    class EnsabledTestClass {
        @Test
        void testWillBeExecuted() {
        }
    }

}
```
---
_@Disabled를 사용할때 이유를 작성 하지 않아도 된다. 하지만 JUnit 팀은 테스트 클래스나 테스트 함수가 왜 비활성화 되었는지에 대한 간단한 설명을 작성할 것을 권장한다._ 

---


## 2.8. Conditional Test Execution
JUnit Jupiter의 ExecutionCondition 확장 API는 특정 조건에 따라 컨테이너나 테스트 베이스를 프로그램적으로 활성화, 비활성화 할 수 있다.
조건을 지정하는 가장 간단한 예는 @Disabled 어노테이션을 지원하는 DisabledCondition이다. (Disabling Tests 참고)
JUnit Jupiter는 @Disabled외에도 어노테이션 기반의 몇가지 조건(org.junit.jupiter.api.condition)을 지원한다. 이 어노테이션을 사용하면 개발자가 선언적으로 컨테이너나 테스트를 활성화, 비활성화 할 수 있다.
복수개의 ExecutionCondition 이 등록되는 경우, 컨테이너나 테스트는 하나의 조건이라도 비활성화 되면 비활성화 된다.
만약 비활성화 된 이유를 제공하고 싶다면, 각각의 어노테이션에는 disabledReason 속성을 작성하면 된다.

---
_**Composed Annotations**  
이후에 작성된 조건 어노테이션들 역시 사용자 정의 어노테이션을 생성하기 위한 meta-annotation으로 사용할 수 있다.
예를 들어, @TestOnMac 어노테이션은 @Test와 @EnabledOnOs를 조합한 어노테이션이다._

---

---
_달리 명시되지 않는 한, 다음 섹션에 나열된 각 조건 어노테이션은 테스트 인터페이스, 테스트 클래스 또는 테스트 메소드에서 한 번만 선언할 수 있다. 조건 어노테이션이 직접적으로, 간접적으로 또는 메타로 한 요소에 여러 번 존재하는 경우, JUnit에 의해 발견된 첫 번째 어노테이션만 사용된다. 추가 선언은 무시된다.  
그러나, 각 조건 어노테이션은 org.junit.jupiter.api.condition 패키지의 다른 조건 어노테이션과 함께 사용될 수 있다._

---

### 2.8.1. Operating System and Architecture Conditions
컨테이너 나 테스트는 @EnabledOnOs와 @DisabledOnOs 어노테이션을 이용해서 특정 운영체제나 아키텍처에서만 실행되도록 지정할 수 있다.

_Conditional execution based on operating system_
```java
@Test
@EnabledOnOs(MAC)
void onlyOnMacOs() {
    // ...
}

@TestOnMac
void testOnMac() {
    // ...
}

@Test
@EnabledOnOs({ LINUX, MAC })
void onLinuxOrMac() {
    // ...
}

@Test
@DisabledOnOs(WINDOWS)
void notOnWindows() {
    // ...
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Test
@EnabledOnOs(MAC)
@interface TestOnMac {
}
```
_Conditional execution based on architecture_
```java
@Test
@EnabledOnOs(architectures = "aarch64")
void onAarch64() {
    // ...
}

@Test
@DisabledOnOs(architectures = "x86_64")
void notOnX86_64() {
    // ...
}

@Test
@EnabledOnOs(value = MAC, architectures = "aarch64")
void onNewMacs() {
    // ...
}

@Test
@DisabledOnOs(value = MAC, architectures = "aarch64")
void notOnNewMacs() {
    // ...
}
```

### 2.8.2. Java Runtime Environment Conditions
컨테이너나 테스트는 @EnabledOnJre와 @DisabledOnJre 어노테이션을 이용해서 특정 버전의 자바 런타임 환경에서만 실행되도록 지정하거나, @EnabledForJreRange와 @DisabledForJreRange 어노테이션을 이용해서 실행되거나 실행되지 않을 JRE의 범위를 지정 할 수 있다. 범위는 JRE.JAVA_8을 하한 (min)으로 JRE.OTHER를 상한 (max)으로 기본값으로 사용하며, 반 개방 범위의 사용을 허용한다.

```java
@Test
@EnabledOnJre(JAVA_8)
void onlyOnJava8() {
    // ...
}

@Test
@EnabledOnJre({ JAVA_9, JAVA_10 })
void onJava9Or10() {
    // ...
}

@Test
@EnabledForJreRange(min = JAVA_9, max = JAVA_11)
void fromJava9to11() {
    // ...
}

@Test
@EnabledForJreRange(min = JAVA_9)
void fromJava9toCurrentJavaFeatureNumber() {
    // ...
}

@Test
@EnabledForJreRange(max = JAVA_11)
void fromJava8To11() {
    // ...
}

@Test
@DisabledOnJre(JAVA_9)
void notOnJava9() {
    // ...
}

@Test
@DisabledForJreRange(min = JAVA_9, max = JAVA_11)
void notFromJava9to11() {
    // ...
}

@Test
@DisabledForJreRange(min = JAVA_9)
void notFromJava9toCurrentJavaFeatureNumber() {
    // ...
}

@Test
@DisabledForJreRange(max = JAVA_11)
void notFromJava8to11() {
    // ...
}
```

### 2.8.3. Native Image Conditions
@EnabledInNativeImage, @DisabledInNativeImage 어노테이션을 이용하여 컨테이너나 테스트가 GraalVM 네이티브 이미지에서만 실행되도록 지정할 수 있다.
이러한 어노테이션은 일반적으로 GraalVM Native Build Tools 프로젝트의 Gradle과 Maven 플러그인을 사용하여 네이티브 이미지 내에서 테스트를 실행할 때 사용된다.

```java
@Test
@EnabledInNativeImage
void onlyWithinNativeImage() {
    // ...
}

@Test
@DisabledInNativeImage
void neverWithinNativeImage() {
    // ...
}
```

### 2.8.4. System Property Conditions
@EnabledIfSystemProperty 와 @DisabledIfSystemProperty annotations을 이용하여 JVM 환경 변수의 값에 따라 테스트를 활성화 또는 비활성화 할 수 있다.
matches 속성으로 지정된 값은 정규 표현식으로 해석된다.

```java
@Test
@EnabledIfSystemProperty(named = "os.arch", matches = ".*64.*")
void onlyOn64BitArchitectures() {
    // ...
}

@Test
@DisabledIfSystemProperty(named = "ci-server", matches = "true")
void notOnCiServer() {
    // ...
}
```
---
_JUnit Jupiter 5.6 이후, @EnabledIfSystemProperty 와 @DisabledIfSystemProperty는 반복 사용이 가능하다.
따라서 이러한 어노테이션은 테스트 인터페이스, 테스트 클래스 또는 테스트 메소드에 여러 번 선언될 수 있다.
특히, 이러한 어노테이션은 직접적, 간접적 또는 메타로 선언될 수 있다._

---

### 2.8.5. Environment Variable Conditions
@EnabledIfEnvironmentVariable, @DisabledIfEnvironmentVariable 어노테이션을 이용해서 OS 환경 변수의 값에 따라 테스트를 활성화 또는 비활성화 할 수 있다.
matches 속성으로 지정된 값은 정규 표현식으로 해석된다.

```java
@Test
@EnabledIfEnvironmentVariable(named = "ENV", matches = "staging-server")
void onlyOnStagingServer() {
    // ...
}

@Test
@DisabledIfEnvironmentVariable(named = "ENV", matches = ".*development.*")
void notOnDeveloperWorkstation() {
    // ...
}
```
---
_JUnit Jupiter 5.6 이후, @EnabledIfEnvironmentVariable 와 @DisabledIfEnvironmentVariable는 반복 사용이 가능하다.
따라서 이러한 어노테이션은 테스트 인터페이스, 테스트 클래스 또는 테스트 메소드에 여러 번 선언될 수 있다.
특히, 이러한 어노테이션은 직접적, 간접적 또는 메타로 선언될 수 있다._

---

### 2.8.6. Custom Conditions
ExecutionCondition을 구현하는 대신 @EnabledIf 와 @DisabledIf 어노테이션을 통해 조건 메소드를 기반으로 컨테이너나 테스트를 활성화 또는 비활성화 할 수 있다.
조건 메소드는 boolean 반환 타입을 가져야 하며 인자를 받지 않거나 단일 ExtensionContext 인자를 받아야 한다.

아래 테스트는 @EnabledIf 와 @DisabledIf 어노테이션에 customCondition 메소드를 설정하여 테스트를 활성화 또는 비활성화 하는 예제를 보여준다.


```java
@Test
@EnabledIf("customCondition")
void enabled() {
    // ...
}

@Test
@DisabledIf("customCondition")
void disabled() {
    // ...
}

boolean customCondition() {
    return true;
}
```
조건 메소드는 테스트 클래스 외부에 위치 할 수 있다. 이 경우 다음 예제와 같이 완전히 정규화된 이름으로 참조되어야 한다.
```java
package example;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIf;

class ExternalCustomConditionDemo {

    @Test
    @EnabledIf("example.ExternalCondition#customCondition")
    void enabled() {
        // ...
    }

}

class ExternalCondition {

    static boolean customCondition() {
        return true;
    }

}
```
---
_조건 메소드가 static 이어야 하는 몇가지 경우들이 있다:_
_@EnabledIf 또는 @DisabledIf 어노테이션이 class 수준에서 사용되는 경우_
_@EnabledIf 또는 @DisabledIf 어노테이션이 @ParameterizedTest 또는 @TestTemplate 메소드에서 사용되는 경우_
_조건 메소드가 외부 클래스에 위치하는 경우_
_그외에도, 조건 메소드는 static 메소드 또는 instance 메소드일 수 있다._ 

_예로, java.awt.GraphicsEnvironment는 현재 환경이 그래픽 디스플레이를 지원하지 않는지를 확인하는 데 사용할 수 있는 public static boolean isHeadless() 메소드를 제공한다.
따라서 아래 예제와 같이 그래픽 지원에 의존하는 테스트가 그러한 지원이 사용 불가능한 경우 비활성화 할 수 있다._
```java
@DisabledIf(value = "java.awt.GraphicsEnvironment#isHeadless", disabledReason = "headless environment")
```

---


## 2.9. Tagging and Filtering
@Tag 어노테이션을 이용해서 클래스나 메소드에 tag를 달 수 있다.
tag는 이후 테스트 검색 및 실행에 사용될 수 있다. tag에 대한 자세한 내용은 JUnit Platform의 Tag 부분 참고.

```java
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

@Tag("fast")
@Tag("model")
class TaggingDemo {

    @Test
    @Tag("taxes")
    void testingTaxCalculation() {
    }

}
```


## 2.10. Test Execution Order
기본적으로, 테스트 클래스와 메소드는 결정적이지만 의도적으로 명확하지 않은 알고리즘을 사용하여 정렬된다.
이렇게 하면 테스트 도구 모음의 후속 실행에서 동일한 순서로 테스트 클래스와 테스트 메서드를 실행하므로 반복 해서 빌드가 가능합니다.

### 2.10.1. Method Order
단위 테스트가 실행 순서에 영향을 받지는 않지만, 특정 테스트 메소드의 실행 순서를 제어하고 싶은 경우가 있다.
예로, 통합테스트나 기능테스트를 작성할때(특별히 @TestInstance(Lifecycle.PER_CLASS)를 적용하는 경우)는 테스트 순서가 중요한 경우가 있다.

테스트 함수의 실행 순서를 제어하기 위해서는 @TestMethodOrder 어노테이션에 MethodOrderer 구현체를 지정하면 된다.
사용자 지정 MethodOrderer를 구현하거나 다음 내장 MethodOrderer 구현 중 하나를 사용할 수 있다.
* MethodOrderer.DisplayName: 테스트 메소드를 display 이름의 알파벳 순서로 정렬한다.
* MethodOrderer.MethodName: 테스트 메소드 이름과 형식 매개 변수 목록에 따라 테스트 메소드를 알파벳 순서로 정렬한다.
* MethodOrderer.OrderAnnotation: @Order 어노테이션에 지정된 값에 따라 테스트 메소드를 정렬한다. 
* MethodOrderer.Random: 테스트 메소드를 난수로 정렬하고 사용자 정의 시드를 구성할 수 있다. 
* MethodOrderer.Alphanumeric: 테스트 메소드 이름과 형식 매개 변수 목록에 따라 테스트 메소드를 알파벳 순서로 정렬한다. MethodOrderer.MethodName가 생기면서 deprecated 되었다. 6.0 부터는 삭제될 것이다.

```java
public class MethodOrderDemo {

    @Nested
    @TestMethodOrder(MethodOrderer.DisplayName.class)
    class DisplayNameDemo {
//        실행 순서
//        testA
//        testB
//        testD()
//        testE
        
        @Test
        @DisplayName("testA")
        void testA() {}

        @Test
        @DisplayName("testB")
        void testB() {}

        @Test
        @DisplayName("testE")
        void testC() {}

        @Test
        void testD() {}
    }

    @Nested
    @TestMethodOrder(MethodOrderer.MethodName.class)
    class MethodNameDemo {
//        실행 순서
//        testA
//        testB
//        testE
//        testD()

        @Test
        @DisplayName("testA")
        void testA() {}

        @Test
        @DisplayName("testB")
        void testB() {}

        @Test
        @DisplayName("testE")
        void testC() {}

        @Test
        void testD() {}
    }


    @Nested
    @TestMethodOrder(MethodOrderer.OrderAnnotation.class)
    class OrderAnnotationDemo {
//        실행순서
//        testB()
//        testD()
//        testC()
//        testA()
            
        @Test
        void testA() {}

        @Test
        @Order(0)
        void testB() {}

        @Test
        @Order(5)
        void testC() {}

        @Test
        @Order(1)
        void testD() {}
    }


    @Nested
    @TestMethodOrder(MethodOrderer.Random.class)
    class RandomDemo {
//        실행순서 가 매번 다름
        @Test
        void testA() {}

        @Test
        void testB() {}

        @Test
        void testC() {}

        @Test
        void testD() {}
    }

}
```

#### Setting the Default Method Orderer
junit.jupiter.testmethod.order.default 설정 값을 통해서 기본 MethodOrderer를 지정(전체 경로를 모두 작성해야 한다)할 수 있다.
@TestMethodOrder 어노테이션으로 설정할때와 마찬가지로 MethodOrderer 구현체를 지정해야한다.
@TestMethodOrder 가 별도로 지정되지 않은 경우에 설정된다.

MethodOrderer.OrderAnnotation 메소드 순서를 기본으로 사용하려면 다음과 같이 설정하면 된다.
(직접 구현한 MethodOrderer의 구현체를 사용하려면 아래와 같이 전체 경로를 작성해 주면 된다.)
```properties
junit.jupiter.testmethod.order.default = org.junit.jupiter.api.MethodOrderer$OrderAnnotation
```

### 2.10.2. Class Order
테스트 클래스들이 일반적으로 그 실행순서에 영향을 받지 않는다 하더라도, 특정 테스트 클래스의 실행 순서를 제어하고 싶은 경우가 있다.

테스트클래스 사이에 의도되지 않은 의존성이 없는지 확인하기 위해 테스트 클래스를 무작위로 실행하고 싶은 경우도 있고,
아래 시나리오 처럼 빌드타임 최적화를 위해 테스트 클래스의 순서를 정하고 싶은 경우도 있다.
* 이전에 실패한 테스트와 빠른 테스트를 먼저 실행: "fail fast" 모드
* 병렬 실행이 활성화된 경우, 더 긴 테스트를 먼저 예약: "shortest test plan execution duration" 모드
* 그외 기타 등등

전체 테스트 클래스의 실행순서를 설정하기 위해서는 junit.jupiter.testclass.order.default 설정 값을 통해서 기본 ClassOrderer를 지정(지정되는 클래스는 ClassOrderer를 구현해야하고, 전체 경로를 모두 작성해야 한다)할 수 있다.
아래 나열된 기본으로 제공하는 ClassOrderer 구현체를 사용해도 되고, ClassOrderer를 직접 구현하여 사용해도 된다.

* ClassOrderer.ClassName: 전체 경로의 클래스 이름 기준으로 알파벳 순서 정렬 한다. 
* ClassOrderer.DisplayName: 클래스의 Display Name 기준으로 알파벳 순서 정렬 한다.
* ClassOrderer.OrderAnnotation: @Order 어노테이션의 숫자 값(value) 기준으로 정렬 한다.
* ClassOrderer.Random: 테스트 클래스를 난수로 정렬하고 사용자 정의 시드를 구성할 수 있다.

```java

@TestClassOrder(ClassOrderer.ClassName.class)
public class MethodOrderDemo {

    @Nested
    class Aaa {
        @Test
        void testA() {}
    }

    @Nested
    class Ccc {
        @Test
        void testC() {}
    }


    @Nested
    class Bbb {
        @Test
        void testB() {}
    }
}
```

기본 ClassOrderer를 지정하고 싶다면 properties 파일((e.g., in src/test/resources/junit-platform.properties))에 아래와 같이 설정하면 된다.
```properties
junit.jupiter.testclass.order.default = org.junit.jupiter.api.ClassOrderer$OrderAnnotation

```
설정된 ClassOrderer는 모든 최상위 테스트 클래스(정적 중첩 테스트 클래스 포함)와 @Nested 테스트 클래스에 적용된다.  
_최상위 테스트 클래스는 서로에게 상대적인 순서를 부여받는다. 반면, @Nested 테스트 클래스는 동일한 클래스에 포함된 다른 @Nested 테스트 클래스에 상대적인 순서를 부여받는다._

@Nested 테스트 클래스의 순서를 지역적으로(locally) 지정하기 위해서는, @TestClassOrder 어노테이션을 상위(@Nested 테스트클래스를 포함하느) 클래스에 사용하면 된다.
이때 @TestClassOrder 어노테이션에 ClassOrderer 구현체를 지정해 준다.
지정된 ClassOrderer는 @Nested 테스트 클래스와 그 하위 @Nested 테스트 클래스에 순차적으로(recursively) 적용된다.

지역적으로(locally) 지정된 @TestClassOrder 어노테이션은 상속받은 @TestClassOrder 어노테이션 또는 junit.jupiter.testclass.order.default 설정 값으로 지정된 ClassOrderer를 항상 오버라이드한다.


## 2.11. Test Instance Lifecycle
In order to allow individual test methods to be executed in isolation and to avoid unexpected side effects due to mutable test instance state, JUnit creates a new instance of each test class before executing each test method (see Definitions). This "per-method" test instance lifecycle is the default behavior in JUnit Jupiter and is analogous to all previous versions of JUnit.

_Please note that the test class will still be instantiated if a given test method is disabled via a condition (e.g., @Disabled, @DisabledOnOs, etc.) even when the "per-method" test instance lifecycle mode is active._

If you would prefer that JUnit Jupiter execute all test methods on the same test instance, annotate your test class with @TestInstance(Lifecycle.PER_CLASS). When using this mode, a new test instance will be created once per test class. Thus, if your test methods rely on state stored in instance variables, you may need to reset that state in @BeforeEach or @AfterEach methods.

The "per-class" mode has some additional benefits over the default "per-method" mode. Specifically, with the "per-class" mode it becomes possible to declare @BeforeAll and @AfterAll on non-static methods as well as on interface default methods. The "per-class" mode therefore also makes it possible to use @BeforeAll and @AfterAll methods in @Nested test classes.

_Beginning with Java 16, @BeforeAll and @AfterAll methods can be declared as static in @Nested test classes._

If you are authoring tests using the Kotlin programming language, you may also find it easier to implement non-static @BeforeAll and @AfterAll lifecycle methods as well as @MethodSource factory methods by switching to the "per-class" test instance lifecycle mode.

### 2.11.1. Changing the Default Test Instance Lifecycle
If a test class or test interface is not annotated with @TestInstance, JUnit Jupiter will use a default lifecycle mode. The standard default mode is PER_METHOD; however, it is possible to change the default for the execution of an entire test plan. To change the default test instance lifecycle mode, set the junit.jupiter.testinstance.lifecycle.default configuration parameter to the name of an enum constant defined in TestInstance.Lifecycle, ignoring case. This can be supplied as a JVM system property, as a configuration parameter in the LauncherDiscoveryRequest that is passed to the Launcher, or via the JUnit Platform configuration file (see Configuration Parameters for details).

For example, to set the default test instance lifecycle mode to Lifecycle.PER_CLASS, you can start your JVM with the following system property.
```shell
-Djunit.jupiter.testinstance.lifecycle.default=per_class
```

Note, however, that setting the default test instance lifecycle mode via the JUnit Platform configuration file is a more robust solution since the configuration file can be checked into a version control system along with your project and can therefore be used within IDEs and your build software.

To set the default test instance lifecycle mode to Lifecycle.PER_CLASS via the JUnit Platform configuration file, create a file named junit-platform.properties in the root of the class path (e.g., src/test/resources) with the following content.

```shell
junit.jupiter.testinstance.lifecycle.default = per_class
```

_Changing the default test instance lifecycle mode can lead to unpredictable results and fragile builds if not applied consistently. For example, if the build configures "per-class" semantics as the default but tests in the IDE are executed using "per-method" semantics, that can make it difficult to debug errors that occur on the build server. It is therefore recommended to change the default in the JUnit Platform configuration file instead of via a JVM system property._

