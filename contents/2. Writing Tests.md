## 2.2 Definitions
### Lifecycle Method
@BeforeAll, @AfterAll, @BeforeEach, @AfterEach

### Test Class
Test class 는 abstract 여서는 안되며, 단 하나의 생성자(constructor)를 가져야 한다.
1. 최상위 class
2. static member class 
3. @Nested 로 정의되고 테스트 메소드를 하나이상 가지고 있는 class


## 2.3 Test Classes and Methods
test 함수와 lifecycle 함수는 현재 class 내부에 선언되거나, 부모 클래스나 interface 로 부터 상속 받는다.
덧 붙여, 테스트 함수와 라이프 사이클 함수는 추상 함수로 선언 될 수 없으면 return value 를 가질 수 없다. 

---
Class 와 method의 가시성
test class, test 함수, lifecycle 함수는 public 일 필요는 없으나 private로 선언되서는 안된다.

일반적으로, 다른 package에서 test class나 test 함수, lifecycle 함수 를 사용하는 경우를 제외하고 public 수정자를 생략하는것을 추천한다.

---
일반적인 test 함수와 lifecycle 함수의 사용 방법은 아래와 같다.
```java
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

class StandardTests {
    @BeforeAll
    static void initAll() {
    }

    @BeforeEach
    void init() {
    }

    @Test
    void succeedingTest() {
    }

    @Test
    void failingTest() {
        fail("a failing test");
    }

    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // not executed
    }

    @Test
    void abortedTest() {
        assumeTrue("abc".contains("Z"));
        fail("test should have been aborted");
    }

    @AfterEach
    void tearDown() {
    }

    @AfterAll
    static void tearDownAll() {
    }
}
```






## 2.4 Display Names
Test classes and test methods can declare custom display names via @DisplayName--with spaces, special characters, and even emojis — that will be displayed in test reports and by test runners and IDEs.
```java
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@DisplayName("A special test case")
class DisplayNameDemo {

    @Test
    @DisplayName("Custom test name containing spaces")
    void testWithDisplayNameContainingSpaces() {
    }

    @Test
    @DisplayName("╯°□°）╯")
    void testWithDisplayNameContainingSpecialCharacters() {
    }

    @Test
    @DisplayName("😱")
    void testWithDisplayNameContainingEmoji() {
    }

}
```

### 2.4.1. Display Name Generators
JUnit Jupiter supports custom display name generators that can be configured via the @DisplayNameGeneration annotation. Values provided via @DisplayName annotations always take precedence over display names generated by a DisplayNameGenerator.

Generators can be created by implementing DisplayNameGenerator. Here are some default ones available in Jupiter:


|DisplayNameGenerator|Behavior|
|---|---|
|Standard|Matches the standard display name generation behavior in place since JUnit Jupiter 5.0 was released.|
|Simple|Removes trailing parentheses for methods with no parameters.|
|ReplaceUnderscores|Replaces underscores with spaces.|
|IndicativeSentences|Generates complete sentences by concatenating the names of the test and the enclosing classes.|

Note that for IndicativeSentences, you can customize the separator and the underlying generator by using @IndicativeSentencesGeneration as shown in the following example.
```java
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DisplayNameGeneration;
import org.junit.jupiter.api.DisplayNameGenerator;
import org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores;
import org.junit.jupiter.api.IndicativeSentencesGeneration;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

class DisplayNameGeneratorDemo {

    @Nested
    @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
    class A_year_is_not_supported {

        @Test
        void if_it_is_zero() {
        }

        @DisplayName("A negative value for year is not supported by the leap year computation.")
        @ParameterizedTest(name = "For example, year {0} is not supported.")
        @ValueSource(ints = { -1, -4 })
        void if_it_is_negative(int year) {
        }

    }

    @Nested
    @IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
    class A_year_is_a_leap_year {

        @Test
        void if_it_is_divisible_by_4_but_not_by_100() {
        }

        @ParameterizedTest(name = "Year {0} is a leap year.")
        @ValueSource(ints = { 2016, 2020, 2048 })
        void if_it_is_one_of_the_following_years(int year) {
        }

    }

}
```
<pre>
+-- DisplayNameGeneratorDemo [OK]
+-- A year is not supported [OK]
| +-- A negative value for year is not supported by the leap year computation. [OK]
| | +-- For example, year -1 is not supported. [OK]
| | '-- For example, year -4 is not supported. [OK]
| '-- if it is zero() [OK]
'-- A year is a leap year [OK]
+-- A year is a leap year -> if it is divisible by 4 but not by 100. [OK]
'-- A year is a leap year -> if it is one of the following years. [OK]
+-- Year 2016 is a leap year. [OK]
+-- Year 2020 is a leap year. [OK]
'-- Year 2048 is a leap year. [OK]
</pre>

### 2.4.2. Setting the Default Display Name Generator
You can use the junit.jupiter.displayname.generator.default configuration parameter to specify the fully qualified class name of the DisplayNameGenerator you would like to use by default. Just like for display name generators configured via the @DisplayNameGeneration annotation, the supplied class has to implement the DisplayNameGenerator interface. The default display name generator will be used for all tests unless the @DisplayNameGeneration annotation is present on an enclosing test class or test interface. Values provided via @DisplayName annotations always take precedence over display names generated by a DisplayNameGenerator.

For example, to use the ReplaceUnderscores display name generator by default, you should set the configuration parameter to the corresponding fully qualified class name (e.g., in src/test/resources/junit-platform.properties):

```java
junit.jupiter.displayname.generator.default = \
org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
```
Similarly, you can specify the fully qualified name of any custom class that implements DisplayNameGenerator.

In summary, the display name for a test class or method is determined according to the following precedence rules:

1. value of the @DisplayName annotation, if present
2. by calling the DisplayNameGenerator specified in the @DisplayNameGeneration annotation, if present
3. by calling the default DisplayNameGenerator configured via the configuration parameter, if present
4. by calling org.junit.jupiter.api.DisplayNameGenerator.Standard